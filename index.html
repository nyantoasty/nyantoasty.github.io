<!DOCTYPE html>
<!-- Version: v2025-09-29-functions-fixed -->
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Pattern Hub</title>
    <link rel="icon" type="image/png" href="/assets/icons/yarn-ball-icon.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#8b5cf6">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111827; }
        .mono { font-family: 'Roboto Mono', monospace; }
        .current-step { background-color: rgba(139, 92, 246, 0.2); border-radius: 0.5rem; }
        .pattern-text p { 
            padding: 0.5rem 0.75rem; 
            margin-bottom: 0.25rem; 
            transition: background-color 0.3s; 
        }
        /* Dynamic pattern-specific colors will be injected here */
        .highlight { background-color: #E6E6FA; color: #1a1a2e; padding: 2px 4px; border-radius: 3px; font-weight: bold; }
        .result-chunk { background-color: #374151; padding: 1em; border-radius: 5px; color: #e0e0e0; overflow-x: auto; white-space: pre; }
        #stitch-locator-ui { transition: opacity 0.3s ease-in-out; }
        .tooltip { visibility: hidden; opacity: 0; transition: opacity 0.2s; position: absolute; z-index: 10; bottom: 125%; left: 50%; transform: translateX(-50%); padding: 0.5rem 1rem; border-radius: 0.375rem; background-color: #1f2937; color: #d1d5db; font-size: 0.875rem; white-space: nowrap; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .tooltip-trigger:hover .tooltip { visibility: visible; opacity: 1; }
        .tooltip::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #1f2937 transparent transparent transparent; }
        .tab-button { padding: 0.5rem 1rem; border-radius: 6px; font-weight: 500; cursor: pointer; transition: all 0.2s; border: 1px solid transparent; }
        .tab-button.active { background-color: #8b5cf6; color: white; }
        .tab-button:not(.active):hover { background-color: #4a5568; }
        .code-block { background-color: #1f2937; border: 1px solid #374151; border-radius: 8px; padding: 1rem; overflow-x: auto; font-family: 'Roboto Mono', monospace; font-size: 0.875rem; line-height: 1.6; color: #d1d5db; }
    </style>
</head>
<body class="bg-gray-900 text-gray-300 antialiased selection:bg-violet-500 selection:text-white">

    <!-- Standalone Generator: Always accessible -->
    <div id="standalone-generator" class="hidden max-w-5xl mx-auto p-4 sm:p-6 lg:p-8">
        <header class="flex justify-between items-center mb-8 border-b border-gray-700 pb-4">
            <h1 class="text-3xl font-bold text-white">AI Pattern Generator</h1>
            <button id="back-to-main" class="bg-violet-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-violet-700 transition-colors">Back to Hub</button>
        </header>
        
        <div class="bg-gray-800 p-6 sm:p-8 rounded-xl shadow-lg">
            <iframe src="Generator.html" class="w-full h-screen border-0 rounded-lg"></iframe>
        </div>
    </div>

    <!-- Auth Container: Shown when logged out -->
    <div id="auth-container" class="min-h-screen flex items-center justify-center">
        <div class="text-center p-8 bg-gray-800 rounded-xl shadow-2xl border border-gray-700">
            <h1 class="text-3xl font-bold text-white mb-4">Welcome to your Pattern Hub</h1>
            <p class="text-gray-400 mb-8">Please sign in to access your patterns and tools.</p>
            <div class="space-y-4">
                <button id="login-btn" class="bg-violet-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-violet-700 transition-colors flex items-center justify-center mx-auto">
                    <svg class="w-6 h-6 mr-3" viewBox="0 0 48 48"><path fill="#FFC107" d="M43.611 20.083H42V20H24v8h11.303c-1.649 4.657-6.08 8-11.303 8c-6.627 0-12-5.373-12-12s5.373-12 12-12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C12.955 4 4 12.955 4 24s8.955 20 20 20s20-8.955 20-20c0-1.341-.138-2.65-.389-3.917z"></path><path fill="#FF3D00" d="m6.306 14.691l6.571 4.819C14.655 15.108 18.961 12 24 12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C16.318 4 9.656 8.337 6.306 14.691z"></path><path fill="#4CAF50" d="M24 44c5.166 0 9.86-1.977 13.409-5.192l-6.19-5.238C29.211 35.091 26.715 36 24 36c-5.222 0-9.618-3.317-11.28-7.962l-6.522 5.025C9.505 39.556 16.227 44 24 44z"></path><path fill="#1976D2" d="M43.611 20.083H42V20H24v8h11.303c-.792 2.237-2.231 4.166-4.087 5.571l6.19 5.238C44.572 36.801 48 30.853 48 24c0-1.341-.138-2.65-.389-3.917z"></path></svg>
                    Sign in with Google
                </button>
                <div class="text-gray-500 text-sm">or</div>
                <button id="guest-generator-btn" class="bg-green-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-green-700 transition-colors">
                    Use AI Pattern Generator (No Sign-in Required)
                </button>
                <button id="debug-btn" class="bg-gray-600 text-white font-medium py-1 px-3 rounded text-xs">
                    üîß Debug Firebase
                </button>
            </div>
        </div>
    </div>

    <!-- App Container: Shown when logged in -->
    <div id="app-container" class="hidden max-w-5xl mx-auto p-4 sm:p-6 lg:p-8">
        <header class="flex flex-col sm:flex-row justify-between items-center mb-8 border-b border-gray-700 pb-4">
            <div class="text-center sm:text-left mb-4 sm:mb-0">
                <h1 class="text-3xl font-bold text-white">Pattern Hub</h1>
                <p id="user-display" class="text-sm text-gray-400">Welcome!</p>
                <p class="text-xs text-gray-500">v2025-09-28-auth-fix</p>
            </div>
            <div class="flex items-center space-x-4">
                 <nav id="app-nav" class="flex items-center space-x-2 bg-gray-800 p-1 rounded-lg">
                    <button data-view="viewer" class="tab-button active">Viewer</button>
                    <button data-view="generator" class="tab-button">Generator</button>
                </nav>
                <button id="standalone-generator-btn" class="bg-green-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-green-700 transition-colors text-sm">Full Generator</button>
                <button id="logout-btn" class="bg-red-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-red-700 transition-colors text-sm">Sign Out</button>
            </div>
        </header>

        <!-- VIEWER SECTION -->
        <div id="viewer-section">
            <header class="text-center mb-8">
                <div class="mb-4">
                    <label for="pattern-selector" class="block text-sm font-medium text-gray-300 mb-2">Select Pattern:</label>
                    <div class="flex items-center justify-center space-x-4">
                        <select id="pattern-selector" class="bg-gray-800 border border-gray-600 text-white rounded-lg px-4 py-2 focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                            <option value="">Loading patterns...</option>
                        </select>
                        <button id="pattern-info-btn" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded-lg text-sm transition-colors" disabled>‚ÑπÔ∏è Info</button>
                    </div>
                </div>
                <h2 id="pattern-name" class="text-4xl font-bold text-white mb-2">Select a pattern to begin</h2>
                <p id="pattern-author" class="text-lg text-violet-300"></p>
                <div id="pattern-details" class="hidden mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                        <div><span class="text-gray-400">Craft:</span> <span id="pattern-craft" class="text-white"></span></div>
                        <div><span class="text-gray-400">Total Steps:</span> <span id="pattern-steps" class="text-white"></span></div>
                        <div><span class="text-gray-400">File:</span> <span id="pattern-file" class="text-gray-300 text-xs"></span></div>
                    </div>
                </div>
            </header>
            <main id="pattern-content" class="space-y-8"></main>
            <div id="stitch-popup" class="hidden fixed bg-gray-700 p-6 rounded-lg shadow-2xl z-50 border border-violet-500 w-11/12 max-w-md">
                <button id="close-popup-btn" class="absolute top-2 right-3 text-2xl text-gray-400 hover:text-white">&times;</button>
                <div id="popup-content"></div>
            </div>
        </div>
        
        <!-- GENERATOR SECTION -->
        <div id="generator-section" class="hidden bg-gray-800 p-6 sm:p-8 rounded-xl shadow-lg">
            <h2 class="text-2xl font-bold text-white mb-6 border-b border-gray-700 pb-4">AI Prompt Generator</h2>
            <div class="space-y-8">
                <div>
                    <h3 class="text-lg font-semibold text-gray-300 mb-3">Step 1: Choose Pattern Format</h3>
                    <div id="pattern-type-selector" class="flex items-center space-x-2 bg-gray-700 p-1 rounded-lg max-w-xs">
                        <button data-type="text" class="w-1/2 tab-button active">Text</button>
                        <button data-type="image" class="w-1/2 tab-button">Image</button>
                    </div>
                    <div id="image-instructions" class="hidden mt-4 p-4 bg-yellow-900 bg-opacity-30 border border-yellow-700 rounded-lg text-yellow-300">
                        <h4 class="font-semibold mb-2">Image-Based Pattern Workflow</h4>
                        <ol class="list-decimal list-inside mt-2 space-y-1 text-sm">
                            <li><strong>Transcribe Image:</strong> Use an AI with vision. Prompt: <span class="mono text-xs bg-gray-900 p-1 rounded">"Please transcribe the text from this image of a pattern."</span></li>
                            <li><strong>Generate JSON:</strong> Paste the transcribed text into Step 2 below.</li>
                        </ol>
                    </div>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-gray-300 mb-3">Step 2: Paste Pattern Text</h3>
                    <textarea id="pattern-input" rows="8" class="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-gray-300 focus:ring-2 focus:ring-violet-500 focus:border-violet-500 transition" placeholder="Paste pattern text here..."></textarea>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-gray-300 mb-3">Step 3: Generate and Copy AI Prompt</h3>
                    <div class="relative">
                        <button id="copy-prompt-button" class="absolute top-3 right-3 bg-gray-600 hover:bg-gray-500 text-white font-medium py-1 px-3 border border-gray-500 rounded-md text-sm transition-colors">
                            <span id="copy-default">Copy</span>
                            <span id="copy-success" class="hidden">Copied!</span>
                        </button>
                        <div id="prompt-output" class="code-block h-64 overflow-y-auto">Paste pattern text to generate the prompt.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="fixed bottom-0 left-0 right-0 bg-gray-900 bg-opacity-80 backdrop-blur-sm border-t border-gray-700 p-4">
        <div id="footer-controls" class="max-w-4xl mx-auto hidden">
            <div class="relative h-20">
                <div id="step-counter-ui" class="absolute inset-0 flex items-center justify-center space-x-6 transition-opacity duration-300">
                    <button id="prev-step" class="w-14 h-14 bg-violet-600 text-white font-bold rounded-full text-3xl flex items-center justify-center shadow-lg hover:bg-violet-700 focus:outline-none focus:ring-2 focus:ring-violet-400 focus:ring-opacity-75 transition-transform transform active:scale-95">-</button>
                    <div class="text-center">
                        <div id="step-type" class="text-sm text-gray-400">ROW</div>
                        <input type="number" id="current-step-input" min="1" class="text-4xl font-bold text-white bg-transparent text-center w-28 focus:outline-none focus:ring-2 focus:ring-violet-500 rounded-lg">
                    </div>
                    <button id="next-step" class="w-14 h-14 bg-violet-600 text-white font-bold rounded-full text-3xl flex items-center justify-center shadow-lg hover:bg-violet-700 focus:outline-none focus:ring-2 focus:ring-violet-400 focus:ring-opacity-75 transition-transform transform active:scale-95">+</button>
                </div>
                <div id="stitch-locator-ui" class="absolute inset-0 flex items-center justify-center space-x-4 transition-opacity duration-300 opacity-0 pointer-events-none">
                    <label for="stitch-input" class="text-lg">Stitch #:</label>
                    <input type="number" id="stitch-input" min="1" class="bg-gray-700 text-white border border-violet-500 rounded-md p-2 w-24 text-center">
                    <button id="find-stitch-btn" class="bg-violet-600 text-white font-bold rounded-md py-2 px-4 hover:bg-violet-700">Find</button>
                </div>
            </div>
            <div class="text-center mt-2">
                <button id="toggle-mode" class="text-violet-300 hover:text-white text-sm">Switch to Stitch Locator</button>
            </div>
        </div>
    </footer>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    
    // --- CONFIG & STATE ---
    // For Firebase JS SDK v7.20.0 and later, measurementId is optional
    const firebaseConfig = {
    apiKey: "AIzaSyBmI_9qHr18VWclwzomAUElLTmgJ_MCI3g",
    authDomain: "arachne-edda2.firebaseapp.com",
    projectId: "arachne-edda2",
    storageBucket: "arachne-edda2.firebasestorage.app",
    messagingSenderId: "285468127259",
    appId: "1:285468127259:web:9a1285684a1a6b9b1548be",
    measurementId: "G-208TQKEXGG"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    let PATTERN_DATA = null;
    let currentStep = 1, maxSteps = 1, progressKey = 'pattern-progress-default';
    let isStitchLocatorMode = false;
    let stitchCountsCache = {};

    // --- UTILITY FUNCTIONS (defined early for global access) ---
    function getInstructionCategory(instruction) {
        // Defensive check: ensure instruction is provided
        if (!instruction || typeof instruction !== 'string') {
            console.warn('getInstructionCategory called with invalid instruction:', instruction);
            return 'main';
        }
        
        // Defensive check: ensure PATTERN_DATA is available
        if (!PATTERN_DATA) {
            console.warn('getInstructionCategory called before PATTERN_DATA is loaded');
            return 'main';
        }
        
        // First check if the pattern defines custom categories
        if(PATTERN_DATA?.categories?.[instruction]) {
            return PATTERN_DATA.categories[instruction];
        }
        
        // Craft-specific category mappings
        const craft = PATTERN_DATA?.metadata?.craft?.toLowerCase();
        
        if(craft === 'knitting') {
            const knittingMap = {
                'k': 'main', 'p': 'main',
                'kfb': 'increase', 'm1l': 'increase', 'm1r': 'increase', 'yo': 'increase',
                'k2tog': 'decrease', 'ssk': 'decrease', 'cdd': 'decrease',
                'pm': 'edge', 'sm': 'edge', 'rm': 'edge'
            };
            return knittingMap[instruction] || 'main';
        } else if(craft === 'crochet') {
            const crochetMap = {
                'ch': 'foundation', 'sc': 'main', 'hdc': 'main', 'dc': 'main', 'tr': 'main',
                'inc': 'increase', 'dec': 'decrease', '2tog': 'decrease',
                'sl st': 'edge', 'ss': 'edge'
            };
            return crochetMap[instruction] || 'main';
        }
        
        // Default fallback categories
        const generalMap = {
            'inc': 'increase', 'increase': 'increase',
            'dec': 'decrease', 'decrease': 'decrease',
            'edge': 'edge', 'border': 'edge'
        };
        
        return generalMap[instruction] || 'main';
    }

    // --- UI ELEMENTS ---
    const authContainer = document.getElementById('auth-container');
    const appContainer = document.getElementById('app-container');
    const standaloneGenerator = document.getElementById('standalone-generator');
    const loginBtn = document.getElementById('login-btn');
    const guestGeneratorBtn = document.getElementById('guest-generator-btn');
    const debugBtn = document.getElementById('debug-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const standaloneGeneratorBtn = document.getElementById('standalone-generator-btn');
    const backToMainBtn = document.getElementById('back-to-main');
    const userDisplay = document.getElementById('user-display');
    const appNav = document.getElementById('app-nav');
    const viewerSection = document.getElementById('viewer-section');
    const generatorSection = document.getElementById('generator-section');
    const footerControls = document.getElementById('footer-controls');
    const patternSelector = document.getElementById('pattern-selector');
    
    let availablePatterns = [];

    // --- AUTHENTICATION ---
    const provider = new GoogleAuthProvider();
    
    // Force account selection and ensure we get fresh tokens
    provider.setCustomParameters({
        prompt: 'select_account'
    });
    
    async function signInWithGoogle() {
        console.log('=== LOGIN BUTTON CLICKED ===');
        console.log('Testing POPUP auth instead of redirect...');
        console.log('Auth object:', auth);
        console.log('Provider object:', provider);
        
        try {
            loginBtn.disabled = true;
            loginBtn.textContent = 'Opening popup...';
            
            console.log('Calling signInWithPopup...');
            const result = await signInWithPopup(auth, provider);
            console.log('‚úÖ signInWithPopup result:', result);
            console.log('User from popup:', result.user.email);
            
            // Don't need to do anything here - onAuthStateChanged will handle it
            
        } catch (error) {
            console.log('‚ùå signInWithPopup failed:');
            console.log('Error object:', error);
            console.log('Error code:', error.code);
            console.log('Error message:', error.message);
            
            if (error.code === 'auth/popup-blocked') {
                alert('Popup was blocked! Please allow popups for this site and try again.');
            } else if (error.code === 'auth/popup-closed-by-user') {
                console.log('User closed popup');
            } else {
                alert('Sign in failed: ' + error.code + ' - ' + error.message);
            }
            
            loginBtn.disabled = false;
            loginBtn.textContent = 'Sign in with Google';
        }
    }
    
    loginBtn.addEventListener('click', signInWithGoogle);

    debugBtn.addEventListener('click', () => {
        console.log('=== üîß FIREBASE DEBUG INFO ===');
        console.log('Firebase app:', app);
        console.log('Firebase auth:', auth);
        console.log('Firebase auth currentUser:', auth.currentUser);
        console.log('Provider:', provider);
        console.log('Current URL:', window.location.href);
        console.log('Document referrer:', document.referrer);
        console.log('Local storage keys:', Object.keys(localStorage));
        console.log('Session storage keys:', Object.keys(sessionStorage));
        
        // Try to manually call getRedirectResult
        console.log('Manually calling getRedirectResult...');
        getRedirectResult(auth).then(result => {
            console.log('Manual getRedirectResult result:', result);
        }).catch(error => {
            console.log('Manual getRedirectResult error:', error);
        });
        
        alert('Debug info logged to console!');
    });

    guestGeneratorBtn.addEventListener('click', () => {
        authContainer.classList.add('hidden');
        standaloneGenerator.classList.remove('hidden');
    });

    logoutBtn.addEventListener('click', () => {
        signOut(auth).catch(error => console.error("Sign out error", error));
    });

    standaloneGeneratorBtn.addEventListener('click', () => {
        authContainer.classList.add('hidden');
        appContainer.classList.add('hidden');
        standaloneGenerator.classList.remove('hidden');
    });

    backToMainBtn.addEventListener('click', () => {
        standaloneGenerator.classList.add('hidden');
        // Check if user is logged in to show appropriate screen
        if (auth.currentUser) {
            appContainer.classList.remove('hidden');
        } else {
            authContainer.classList.remove('hidden');
        }
    });

    // --- AUTHORIZATION & APP STATE ---
    
    function showNotAuthorized(user) {
        authContainer.classList.add('hidden');
        appContainer.classList.remove('hidden');
        userDisplay.textContent = `Access Denied for ${user.email}`;
        viewerSection.innerHTML = `<div class="text-center p-8 bg-gray-800 rounded-lg"><h2 class="text-2xl font-bold text-red-400">Not Authorized</h2><p class="text-gray-400 mt-2">Your account does not have permission to view this content.</p></div>`;
        generatorSection.classList.add('hidden');
        footerControls.classList.add('hidden');
    }

    function showApplication(user, userData = null, roleData = null) {
        try {
            authContainer.classList.add('hidden');
            appContainer.classList.remove('hidden');
            
            // Display user info with role
            const roleName = roleData ? roleData.name : 'User';
            userDisplay.textContent = `${user.displayName || user.email} (${roleName})`;
            
            console.log('Initializing application for user:', user.email);
            console.log('User role:', userData?.role);
            console.log('User permissions:', roleData?.permissions);
            
            // Store user data globally for use in other parts of the app
            window.currentUser = user;
            window.currentUserData = userData;
            window.currentUserRole = roleData;
            
            discoverPatterns().then(() => {
                console.log('Patterns discovered, initializing viewer');
                initializeViewer();
            }).catch(error => {
                console.error('Error during pattern discovery or viewer initialization:', error);
            });
        } catch (error) {
            console.error('Error in showApplication:', error);
        }
    }
    
    async function discoverPatterns() {
        try {
            // List of known patterns - add new patterns here!
            const knownPatterns = [
                { filename: 'neon-sky-full.json', name: 'Neon Sky Shawl' }
                // To add more patterns:
                // 1. Save your JSON file in the /patterns/ directory
                // 2. Add an entry here like: { filename: 'your-pattern.json', name: 'Display Name' }
                // The system will automatically load the actual metadata from the JSON file
            ];
            
            availablePatterns = [];
            
            for (const pattern of knownPatterns) {
                try {
                    // Add cache busting parameter to force reload
                    const cacheBust = new Date().getTime();
                    const response = await fetch(`/patterns/${pattern.filename}?v=${cacheBust}`);
                    if (response.ok) {
                        const data = await response.json();
                        availablePatterns.push({
                            filename: pattern.filename,
                            name: data.metadata.name,
                            author: data.metadata.author,
                            craft: data.metadata.craft || 'Unknown',
                            maxSteps: data.metadata.maxSteps
                        });
                    }
                } catch (error) {
                    console.warn(`Failed to load pattern ${pattern.filename}:`, error);
                }
            }
            
            populatePatternSelector();
        } catch (error) {
            console.error('Error discovering patterns:', error);
        }
    }
    
    function populatePatternSelector() {
        const selector = document.getElementById('pattern-selector');
        selector.innerHTML = '<option value="">-- Select a pattern --</option>';
        
        availablePatterns.forEach(pattern => {
            const option = document.createElement('option');
            option.value = pattern.filename;
            option.textContent = `${pattern.name} by ${pattern.author}`;
            selector.appendChild(option);
        });
        
        selector.addEventListener('change', async (e) => {
            const infoBtn = document.getElementById('pattern-info-btn');
            const detailsDiv = document.getElementById('pattern-details');
            
            if (e.target.value && infoBtn && detailsDiv) {
                infoBtn.disabled = false;
                await loadSelectedPattern(e.target.value);
            } else if (infoBtn && detailsDiv) {
                infoBtn.disabled = true;
                detailsDiv.classList.add('hidden');
                resetViewer();
            }
        });
        
        // Add pattern info button functionality
        const infoBtn = document.getElementById('pattern-info-btn');
        if (infoBtn) {
            infoBtn.addEventListener('click', () => {
                const detailsDiv = document.getElementById('pattern-details');
                const selectedPattern = availablePatterns.find(p => p.filename === document.getElementById('pattern-selector').value);
                
                if (selectedPattern && PATTERN_DATA && detailsDiv) {
                    const craftEl = document.getElementById('pattern-craft');
                    const stepsEl = document.getElementById('pattern-steps');
                    const fileEl = document.getElementById('pattern-file');
                    
                    if (craftEl) craftEl.textContent = PATTERN_DATA.metadata.craft || 'Unknown';
                    if (stepsEl) stepsEl.textContent = PATTERN_DATA.metadata.maxSteps || 'Unknown';
                    if (fileEl) fileEl.textContent = selectedPattern.filename;
                    detailsDiv.classList.toggle('hidden');
                }
            });
        }
    }
    
    function resetViewer() {
        document.getElementById('pattern-name').textContent = 'Select a pattern to begin';
        document.getElementById('pattern-author').textContent = '';
        document.getElementById('pattern-content').innerHTML = '';
        footerControls.classList.add('hidden');
        PATTERN_DATA = null;
        
        // Remove pattern-specific theme
        const existingStyle = document.getElementById('pattern-theme');
        if (existingStyle) {
            existingStyle.remove();
        }
    }
    
    async function checkAuthState() {
        console.log('=== STEP 1: Starting checkAuthState ===');
        
        // Set up auth state listener FIRST to catch any immediate auth changes
        console.log('=== STEP 1.5: Setting up auth state listener ===');
        onAuthStateChanged(auth, async (user) => {
            console.log('üî• AUTH STATE CHANGED EVENT FIRED!');
            console.log('Raw user object:', user);
            console.log('User from auth state change:', user ? user.email : 'null');
            console.log('User is null?', user === null);
            console.log('User is undefined?', user === undefined);
            
            if (user) {
                console.log('‚úÖ USER FOUND VIA AUTH STATE CHANGE!');
                console.log('User email:', user.email);
                console.log('User UID:', user.uid);
                console.log('User emailVerified:', user.emailVerified);
                console.log('User providerData:', user.providerData);
                
                try {
                    // Check if user exists in the users collection
                    console.log('üîç Checking user in Firebase users collection...');
                    console.log('Looking for document path: users/' + user.uid);
                    
                    const userDocRef = doc(db, "users", user.uid);
                    const userDocSnap = await getDoc(userDocRef);
                    
                    console.log('User document exists:', userDocSnap.exists());
                    
                    if (userDocSnap.exists()) {
                        // User exists, get their role and permissions
                        const userData = userDocSnap.data();
                        console.log('‚úÖ User found in database:', userData);
                        
                        // Get role details
                        const roleDocRef = doc(db, "roles", userData.role);
                        const roleDocSnap = await getDoc(roleDocRef);
                        
                        if (roleDocSnap.exists()) {
                            const roleData = roleDocSnap.data();
                            console.log('‚úÖ User role data:', roleData);
                            
                            // Check if user has permission to view patterns
                            if (roleData.permissions && roleData.permissions.includes('view_patterns')) {
                                console.log('üéâ User authorized - showing application');
                                
                                // Update last login
                                await updateDoc(userDocRef, {
                                    lastLogin: new Date().toISOString()
                                });
                                
                                showApplication(user, userData, roleData);
                            } else {
                                console.log('‚ùå User role does not have view_patterns permission');
                                showNotAuthorized(user);
                            }
                        } else {
                            console.log('‚ùå User role not found in roles collection');
                            showNotAuthorized(user);
                        }
                    } else {
                        // User doesn't exist, create them with default 'viewer' role
                        console.log('üë§ New user detected - creating user document');
                        console.log('User UID:', user.uid);
                        console.log('User email:', user.email);
                        console.log('User displayName:', user.displayName);
                        
                        try {
                            const newUserData = {
                                email: user.email,
                                displayName: user.displayName || user.email.split('@')[0],
                                role: 'viewer',
                                createdAt: new Date().toISOString(),
                                lastLogin: new Date().toISOString()
                            };
                            
                            console.log('Creating user document with data:', newUserData);
                            await setDoc(userDocRef, newUserData);
                            console.log('‚úÖ Successfully created new user document');
                            
                            // Get the viewer role permissions
                            const roleDocRef = doc(db, "roles", "viewer");
                            const roleDocSnap = await getDoc(roleDocRef);
                            const roleData = roleDocSnap.exists() ? roleDocSnap.data() : { permissions: ['view_patterns'], name: 'Viewer' };
                            
                            console.log('New user role data:', roleData);
                            showApplication(user, newUserData, roleData);
                            
                        } catch (createError) {
                            console.error('üö® Error creating user document:', createError);
                            console.log('Create error code:', createError.code);
                            console.log('Create error message:', createError.message);
                            
                            if (createError.code === 'permission-denied') {
                                alert('Permission denied when creating user account. Please check Firebase security rules.');
                            } else {
                                alert(`Error creating user account: ${createError.message}`);
                            }
                            
                            showNotAuthorized(user);
                        }
                    }
                    
                } catch (error) {
                    console.error('üö® Error checking user authorization:', error);
                    console.log('Error code:', error.code);
                    console.log('Error message:', error.message);
                    
                    if (error.code === 'permission-denied') {
                        alert('Permission denied. Please check your Firebase security rules.');
                    } else {
                        alert(`Authentication error: ${error.message}`);
                    }
                    
                    showNotAuthorized(user);
                }
                
            } else {
                console.log('Auth state change: no user - showing login screen');
                authContainer.classList.remove('hidden');
                appContainer.classList.add('hidden');
            }
        });
        
        console.log('=== STEP 2: Checking current auth state (popup method) ===');
        console.log('Current URL:', window.location.href);
        
        // With popup auth, we don't need to check for redirect results
        console.log('Using popup auth - skipping redirect result check');
        
        console.log('=== STEP 3: Checking current user ===');
        const currentUser = auth.currentUser;
        console.log('auth.currentUser:', currentUser);
        
        if (currentUser) {
            console.log('‚úÖ Current user found:', currentUser.email);
            // Trigger the auth state change manually if needed
            console.log('Current user exists, but auth state change should handle this');
        }
        
        console.log('=== STEP 4: No user found, showing login screen ===');
        authContainer.classList.remove('hidden');
        appContainer.classList.add('hidden');
    }

    // --- INITIALIZATION ---
    console.log('Script loaded, initializing app...');
    console.log('Current URL:', window.location.href);
    console.log('URL params:', window.location.search);
    
    // Add global error handlers to catch any errors we might miss
    window.addEventListener('error', (event) => {
        console.log('üö® GLOBAL ERROR CAUGHT:', event.error);
        console.log('Error message:', event.message);
        console.log('Error filename:', event.filename);
        console.log('Error line:', event.lineno);
    });
    
    window.addEventListener('unhandledrejection', (event) => {
        console.log('üö® UNHANDLED PROMISE REJECTION:', event.reason);
        console.log('Promise:', event.promise);
    });
    
    // Check if we just came back from a redirect (Google referrer is key indicator)
    const hasGoogleReferrer = document.referrer.includes('accounts.google.com') || 
                             document.referrer.includes('google.com');
    const hasAuthParams = window.location.search.includes('code') || 
                         window.location.search.includes('state') || 
                         window.location.hash.includes('access_token');
    
    console.log('Google referrer detected:', hasGoogleReferrer);
    console.log('Auth URL params detected:', hasAuthParams);
    console.log('Document referrer:', document.referrer);
    
    // If we have any indication we came from Google auth, check immediately
    if (hasGoogleReferrer || hasAuthParams) {
        console.log('üîÑ DETECTED RETURN FROM GOOGLE - checking auth immediately (no delay)');
        checkAuthState();
    } else {
        console.log('üîç Normal page load - checking auth with small delay');
        setTimeout(() => {
            checkAuthState();
        }, 500);
    }

    // --- MAIN APP NAVIGATION ---
    appNav.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            const view = e.target.dataset.view;
            appNav.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            e.target.classList.add('active');
            
            if (view === 'viewer') {
                viewerSection.classList.remove('hidden');
                generatorSection.classList.add('hidden');
                footerControls.classList.remove('hidden');
            } else if (view === 'generator') {
                viewerSection.classList.add('hidden');
                generatorSection.classList.remove('hidden');
                footerControls.classList.add('hidden');
            }
        }
    });

    // --- VIEWER LOGIC (Your existing functions) ---
    async function initializeViewer() {
        const patternNameEl = document.getElementById('pattern-name');
        const patternAuthorEl = document.getElementById('pattern-author');
        const patternContentEl = document.getElementById('pattern-content');
        const stepInput = document.getElementById('current-step-input');
        const prevBtn = document.getElementById('prev-step');
        const nextBtn = document.getElementById('next-step');
        const stepTypeEl = document.getElementById('step-type');
        const toggleModeBtn = document.getElementById('toggle-mode');
        const findStitchBtn = document.getElementById('find-stitch-btn');
        const stitchInput = document.getElementById('stitch-input');
        const stitchPopup = document.getElementById('stitch-popup');
        const popupContent = document.getElementById('popup-content');
        const closePopupBtn = document.getElementById('close-popup-btn');

        async function loadPatternData(filename) {
            try {
                const response = await fetch(`/patterns/${filename}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                PATTERN_DATA = await response.json();
            } catch (error) {
                console.error("Could not load pattern data:", error);
                patternNameEl.textContent = "Error";
                patternContentEl.innerHTML = `<p class="text-center text-red-400">Failed to load pattern file. Check path and console.</p>`;
            }
        }

        // Global function for generating glossary
        function generateGlossary() {
            // Defensive check: ensure PATTERN_DATA is loaded
            if (!PATTERN_DATA || !PATTERN_DATA.glossary || Object.keys(PATTERN_DATA.glossary).length === 0) {
                console.log('No glossary data available or PATTERN_DATA not loaded');
                return;
            }
            
            let glossaryHTML = '<h2 class="text-2xl font-semibold text-white mb-4">Stitch Glossary</h2><div class="grid grid-cols-2 md:grid-cols-3 gap-4">';
            
            for (const key in PATTERN_DATA.glossary) {
                const item = PATTERN_DATA.glossary[key];
                if (item && item.name && item.description) {
                    // Add stitch count if available
                    const stitchInfo = item.stitchCount !== undefined ? ` (${item.stitchCount} st)` : '';
                    glossaryHTML += `<div><h3 class="font-bold text-violet-300">${item.name} (${key})${stitchInfo}</h3><p class="text-sm text-gray-400">${item.description}</p></div>`;
                }
            }
            
            glossaryHTML += '</div>';
            const section = document.createElement('section');
            section.className = 'bg-gray-800 p-6 rounded-lg shadow-lg';
            section.innerHTML = glossaryHTML;
            
            // Defensive check: ensure patternContentEl exists
            if (patternContentEl) {
                patternContentEl.appendChild(section);
            } else {
                console.error('patternContentEl not found when trying to append glossary');
            }
        }

        function setupViewer() {
            if (!PATTERN_DATA) return;
            footerControls.classList.remove('hidden');
            const { name, author, maxSteps: max } = PATTERN_DATA.metadata;
            patternNameEl.textContent = name;
            patternAuthorEl.textContent = `by ${author}`;
            maxSteps = max;
            stepInput.max = maxSteps;
            progressKey = `pattern-progress-${name.replace(/\s+/g, '-')}`;
            
            patternContentEl.innerHTML = '';
            generateGlossary();
            generateInstructions();
            loadProgress();
        }
        function generateInstructions(){
            const section=document.createElement('section');
            section.className='bg-gray-800 p-6 rounded-lg shadow-lg pattern-text';
            section.innerHTML='<h2 class="text-2xl font-semibold text-white mb-4">Instructions</h2>';
            
            console.log(`Generating instructions for ${PATTERN_DATA.instructions.length} instruction blocks`);
            
            PATTERN_DATA.instructions.forEach((instr, index)=>{
                console.log(`Processing instruction ${index}:`, instr);
                const p=document.createElement('p');
                if(instr.step)p.dataset.step=instr.step;
                if(instr.stepRange){
                    p.dataset.stepStart=instr.stepRange[0];
                    p.dataset.stepEnd=instr.stepRange[1];
                }
                
                // Generate display text from the JSON structure
                let instructionHTML = generateDisplayText(instr);
                console.log(`Generated HTML for instruction ${index}:`, instructionHTML);
                
                if (instructionHTML && instructionHTML.trim() !== '') {
                    p.innerHTML=addTooltips(instructionHTML);
                    section.appendChild(p);
                    console.log(`Added instruction ${index} to DOM`);
                } else {
                    console.warn(`Empty instruction HTML for instruction ${index}:`, instr);
                }
            });
            
            console.log(`Final section contains ${section.children.length} instruction elements`);
            patternContentEl.appendChild(section);
        }
        
        function generateDisplayText(instr) {
            // Handle special instructions
            if (instr.type === 'specialInstruction') {
                return `<b>Step ${instr.step || instr.stepRange?.join('-') || ''}:</b> ${instr.description}`;
            }
            
            // Handle step ranges
            if (instr.stepRange) {
                let stepText = `<b>Steps ${instr.stepRange[0]}-${instr.stepRange[1]}`;
                if (instr.stepType) stepText += ` (${instr.stepType})`;
                stepText += `:</b>`;
                
                if (instr.dynamicChunks) {
                    // For dynamic chunks, give a general description
                    if (instr.side === 'rs' || instr.side === 'RS') {
                        stepText += ' Increase rows: k3, kfb, k to marker, m1L, sm, k1, m1R, k to last 4, kfb, k3';
                    } else if (instr.side === 'ws' || instr.side === 'WS') {
                        stepText += ' Even rows: k3, purl to last 3, k3';
                    }
                } else if (instr.chunks) {
                    stepText += ' ' + formatChunksForDisplay(instr.chunks);
                }
                return stepText;
            }
            
            // Handle single steps
            if (instr.step !== undefined) {
                let stepText = `<b>Step ${instr.step}`;
                if (instr.side) stepText += ` (${instr.side.toUpperCase()})`;
                stepText += ':</b>';
                
                if (instr.chunks) {
                    stepText += ' ' + formatChunksForDisplay(instr.chunks);
                }
                
                if (instr.stitchCount) {
                    stepText += ` (${instr.stitchCount} sts)`;
                }
                
                return stepText;
            }
            
            return 'Instruction data incomplete';
        }
        
        function formatChunksForDisplay(chunks) {
            let display = [];
            chunks.forEach(chunk => {
                if (chunk.repeat) {
                    let repeatText = '(' + chunk.repeat.instructions.map(inst => 
                        `${inst.instruction}${inst.count > 1 ? inst.count : ''}`
                    ).join(', ') + `)`;
                    if (chunk.repeat.count > 1) repeatText += ` ${chunk.repeat.count} times`;
                    display.push(repeatText);
                } else {
                    let chunkText = chunk.instruction;
                    if (chunk.count > 1) chunkText += chunk.count;
                    display.push(chunkText);
                }
            });
            return display.join(', ');
        }
        function addTooltips(text){if(!PATTERN_DATA.glossary)return text;const regex=new RegExp(`\\b(${Object.keys(PATTERN_DATA.glossary).join('|')})\\b(?![^<]*?>)`,'g');return text.replace(regex,(match)=>{const term=PATTERN_DATA.glossary[match];if(!term)return match;return`<span class="relative tooltip-trigger font-semibold cursor-pointer underline decoration-dotted decoration-1">${match}<span class="tooltip mono">${term.name}</span></span>`;});}
        function getStitchCount(stepNumber){
            if(stitchCountsCache[stepNumber])return stitchCountsCache[stepNumber];
            
            const instr=findInstructionForStep(stepNumber);
            
            // Try to get direct stitch count from instruction
            if(instr && instr.stitchCount){
                stitchCountsCache[stepNumber]=instr.stitchCount;
                return instr.stitchCount;
            }
            
            // Calculate based on previous step and change
            if(stepNumber>1){
                const prevCount=getStitchCount(stepNumber-1);
                let currentIncrease = 0;
                
                // Parse stitch count change
                if(instr && instr.stitchCountChange) {
                    if(typeof instr.stitchCountChange === 'string') {
                        if(instr.stitchCountChange.startsWith('+')) {
                            currentIncrease = parseInt(instr.stitchCountChange.substring(1), 10) || 0;
                        } else if(instr.stitchCountChange.startsWith('-')) {
                            currentIncrease = -parseInt(instr.stitchCountChange.substring(1), 10) || 0;
                        } else if(instr.stitchCountChange === '0') {
                            currentIncrease = 0;
                        }
                    } else if(typeof instr.stitchCountChange === 'number') {
                        currentIncrease = instr.stitchCountChange;
                    }
                }
                
                const count = prevCount + currentIncrease;
                stitchCountsCache[stepNumber] = count;
                return count;
            }
            
            // Fallback to first instruction
            const firstInstr = PATTERN_DATA.instructions.find(i => i.step === 1);
            return firstInstr?.stitchCount || 11; // Default starting count for this pattern
        }
        function expandPattern(patternArray){const expanded=[];patternArray.forEach(p=>{const match=p.match(/^([a-zA-Z_]+)(\d+)$/);if(match){const instruction=match[1];const count=parseInt(match[2],10);for(let i=0;i<count;i++)expanded.push(instruction);}else{expanded.push(p);}});return expanded;}
        function generateDynamicChunks(stepNumber){
            const instruction=findInstructionForStep(stepNumber);
            if(!instruction||!instruction.dynamicChunks)return null;
            
            // Use the chunks from the instruction as a template
            if(!instruction.chunks || !Array.isArray(instruction.chunks)) return null;
            
            const prevCount=getStitchCount(stepNumber-1);
            
            // Process each chunk, expanding dynamic placeholders
            return instruction.chunks.map(chunk => {
                const chunkCopy = {...chunk};
                
                // Handle dynamic count values
                if(typeof chunkCopy.count === 'string') {
                    if(chunkCopy.count === 'to marker') {
                        // Calculate stitches to marker based on pattern structure
                        chunkCopy.count = Math.max(1, Math.floor((prevCount - 7) / 2));
                    } else if(chunkCopy.count === 'to last 3') {
                        chunkCopy.count = Math.max(1, prevCount - 6);
                    } else if(chunkCopy.count === 'to last 4') {
                        chunkCopy.count = Math.max(1, Math.floor((prevCount - 7) / 2));
                    }
                    // Add more dynamic count patterns as needed
                }
                
                return {
                    name: `${chunkCopy.instruction.toUpperCase()}${chunkCopy.count > 1 ? chunkCopy.count : ''}`,
                    category: getInstructionCategory(chunkCopy.instruction),
                    pattern: [chunkCopy.count > 1 ? `${chunkCopy.instruction}${chunkCopy.count}` : chunkCopy.instruction]
                };
            });
        }
        
        function convertJSONChunksToInternalFormat(jsonChunks) {
            // Convert the JSON chunk format to the internal format expected by the stitch locator
            const converted = [];
            
            jsonChunks.forEach(chunk => {
                if (chunk.repeat) {
                    // Handle repeat structures
                    const pattern = chunk.repeat.instructions.map(inst => {
                        if (inst.count > 1) {
                            return `${inst.instruction}${inst.count}`;
                        }
                        return inst.instruction;
                    });
                    
                    converted.push({
                        name: `Repeat ${chunk.repeat.count} times`,
                        category: "main", // Default category
                        repeats: chunk.repeat.count,
                        pattern: pattern
                    });
                } else {
                    // Handle regular chunks
                    const pattern = chunk.count > 1 ? [`${chunk.instruction}${chunk.count}`] : [chunk.instruction];
                    converted.push({
                        name: chunk.instruction.toUpperCase(),
                        category: getInstructionCategory(chunk.instruction),
                        pattern: pattern
                    });
                }
            });
            
            return converted;
        }
        function getPatternForStitch(stepNumber,stitchNumber){
            const totalStitches=getStitchCount(stepNumber);
            if(stitchNumber<1||stitchNumber>totalStitches)return null;
            
            let instruction={...findInstructionForStep(stepNumber)};
            let chunks = null;
            
            if(instruction.dynamicChunks){
                chunks = generateDynamicChunks(stepNumber);
            } else if (instruction.chunks) {
                chunks = convertJSONChunksToInternalFormat(instruction.chunks);
            }
            
            if(!chunks){
                return{
                    sectionName:"This is a repeating instruction section.",
                    patternChunk:"Stitch-by-stitch data is not yet defined for this row type."
                };
            }
            
            let cumulativeStitches=0;
            for(const chunk of chunks){
                const expandedPattern=expandPattern(chunk.pattern);
                const repeats=chunk.repeats||1;
                const chunkStitchCount=expandedPattern.length*repeats;
                
                if(stitchNumber<=cumulativeStitches+chunkStitchCount){
                    const stitchInSection=stitchNumber-cumulativeStitches;
                    let sectionName=`<span class="${chunk.category||''}">${chunk.name}</span>`;
                    let fullPatternSequence=[];
                    
                    for(let i=0;i<repeats;i++){
                        fullPatternSequence.push(...expandedPattern);
                    }
                    
                    if(repeats>1){
                        const repeatNum=Math.ceil(stitchInSection/expandedPattern.length);
                        sectionName+=` (Repeat ${repeatNum} of ${repeats})`;
                    }
                    
                    const targetIndex=stitchInSection-1;
                    const windowSize=4;
                    const start=Math.max(0,targetIndex-windowSize);
                    const end=Math.min(fullPatternSequence.length,targetIndex+windowSize+1);
                    const patternWindow=fullPatternSequence.slice(start,end);
                    
                    let patternChunk=patternWindow.map((stitch,index)=>{
                        return(start+index===targetIndex)?`<span class="highlight">${stitch}</span>`:stitch;
                    }).join(' ');
                    
                    if(start>0)patternChunk='... '+patternChunk;
                    if(end<fullPatternSequence.length)patternChunk+=' ...';
                    
                    return{sectionName,patternChunk};
                }
                cumulativeStitches+=chunkStitchCount;
            }
            return null;
        }
        function loadProgress(){const savedStep=localStorage.getItem(progressKey);currentStep=savedStep?parseInt(savedStep,10):1;updateDisplay(false);}
        function saveProgress() { localStorage.setItem(progressKey, currentStep); }
        function updateDisplay(shouldScroll=true){
            stepInput.value=currentStep;
            const currentInstruction=findInstructionForStep(currentStep);
            console.log(`Step ${currentStep}: Found instruction:`, currentInstruction);
            if(currentInstruction){
                stepTypeEl.textContent=currentInstruction.type?.toUpperCase()||'STEP';
            }
            highlightCurrentStep(shouldScroll);
            saveProgress();
            if(isStitchLocatorMode)stitchInput.max=getStitchCount(currentStep);
        }
        function findInstructionForStep(stepNumber) { 
            return PATTERN_DATA.instructions.find(instr=>{
                if(instr.step) return instr.step===stepNumber;
                if(instr.stepRange){
                    const[start,end]=instr.stepRange;
                    if(stepNumber>=start&&stepNumber<=end){
                        if(!instr.stepType) return true;
                        if(instr.stepType==='odd'&&stepNumber%2!==0) return true;
                        if(instr.stepType==='even'&&stepNumber%2===0) return true;
                    }
                } 
                return false;
            });
        }
        function findStepElement(stepNumber) { 
            const element = Array.from(document.querySelectorAll('[data-step], [data-step-start]')).find(el=>{
                const step=parseInt(el.dataset.step,10);
                if(step===stepNumber) return true;
                const start=parseInt(el.dataset.stepStart,10);
                const end=parseInt(el.dataset.stepEnd,10);
                return(stepNumber>=start&&stepNumber<=end);
            });
            console.log(`Finding element for step ${stepNumber}:`, element);
            return element;
        }
        function highlightCurrentStep(shouldScroll){
            document.querySelectorAll('.current-step').forEach(el=>el.classList.remove('current-step'));
            const stepElement=findStepElement(currentStep);
            if(stepElement){
                stepElement.classList.add('current-step');
                console.log(`Highlighted step ${currentStep}, scrolling:`, shouldScroll);
                if(shouldScroll) stepElement.scrollIntoView({behavior:'smooth',block:'center'});
            } else {
                console.log(`No element found for step ${currentStep}`);
            }
        }
        
        prevBtn.addEventListener('click', () => { if (currentStep > 1) { currentStep--; updateDisplay(); } });
        nextBtn.addEventListener('click', () => { if (currentStep < maxSteps) { currentStep++; updateDisplay(); } });
        stepInput.addEventListener('change', () => { let newStep = parseInt(stepInput.value); if (isNaN(newStep) || newStep < 1) newStep = 1; if (newStep > maxSteps) newStep = maxSteps; currentStep = newStep; updateDisplay(); });
        document.addEventListener('keydown', (e) => { if (document.activeElement === stepInput || document.activeElement === stitchInput) return; if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {e.preventDefault(); nextBtn.click();} if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {e.preventDefault(); prevBtn.click();}});
        toggleModeBtn.addEventListener('click',()=>{isStitchLocatorMode=!isStitchLocatorMode;stitchPopup.classList.add('hidden');document.getElementById('step-counter-ui').classList.toggle('opacity-0');document.getElementById('step-counter-ui').classList.toggle('pointer-events-none');document.getElementById('stitch-locator-ui').classList.toggle('opacity-0');document.getElementById('stitch-locator-ui').classList.toggle('pointer-events-none');if(isStitchLocatorMode){toggleModeBtn.textContent='Switch to Step Counter';stitchInput.value='';stitchInput.max=getStitchCount(currentStep);stitchInput.focus();}else{toggleModeBtn.textContent='Switch to Stitch Locator';}});
        closePopupBtn.addEventListener('click', () => stitchPopup.classList.add('hidden'));
        findStitchBtn.addEventListener('click',()=>{const stitchNumber=parseInt(stitchInput.value);const patternInfo=getPatternForStitch(currentStep,stitchNumber);if(patternInfo){popupContent.innerHTML=`<h4 class="text-xl font-semibold text-white mb-2">Location (Row ${currentStep}, Stitch ${stitchNumber}):</h4><p class="mb-4">${patternInfo.sectionName}</p><h4 class="text-xl font-semibold text-white mb-2">Your Current Position:</h4><div class="result-chunk mono">${patternInfo.patternChunk}</div>`;stitchPopup.style.top='50%';stitchPopup.style.left='50%';stitchPopup.style.transform='translate(-50%, -50%)';stitchPopup.classList.remove('hidden');}else{popupContent.innerHTML=`<div class="text-white text-center"><p>Invalid stitch number for Row ${currentStep}. Please enter a number between 1 and ${getStitchCount(currentStep)}.</p></div>`;stitchPopup.style.top='50%';stitchPopup.style.left='50%';stitchPopup.style.transform='translate(-50%, -50%)';stitchPopup.classList.remove('hidden');}});

        // Pattern will be loaded when selected from dropdown
        // setupViewer will be called by loadSelectedPattern
        
        function generatePatternTheme() {
            // Remove existing pattern theme
            const existingStyle = document.getElementById('pattern-theme');
            if (existingStyle) {
                existingStyle.remove();
            }
            
            // Collect all unique categories from the pattern
            const categories = new Set();
            
            PATTERN_DATA.instructions.forEach(instr => {
                if (instr.chunks) {
                    instr.chunks.forEach(chunk => {
                        // Add category based on instruction type
                        if (chunk.instruction) {
                            const category = getInstructionCategory(chunk.instruction);
                            categories.add(category);
                        }
                        // Also check repeat instructions
                        if (chunk.repeat && chunk.repeat.instructions) {
                            chunk.repeat.instructions.forEach(repeatInstr => {
                                const category = getInstructionCategory(repeatInstr.instruction);
                                categories.add(category);
                            });
                        }
                    });
                }
            });
            
            // Add standard categories for dynamic chunks
            categories.add('edge');
            categories.add('main');  
            categories.add('increase');
            categories.add('spine');
            
            // Default color palette
            const colorPalette = [
                '#d8b4fe', // purple-300 (edge/structural)
                '#86efac', // green-300 (increases)  
                '#93c5fd', // blue-300 (main/body)
                '#f87171', // red-300 (spine/center)
                '#fcd34d', // yellow-300 (lace-1)
                '#f9a8d4', // pink-300 (lace-2) 
                '#a7f3d0', // emerald-300 (lace-3)
                '#c4b5fd', // violet-300
                '#fbbf24', // amber-400
                '#34d399', // emerald-400
                '#60a5fa', // blue-400
                '#f472b6', // pink-400
                '#a78bfa', // violet-400
                '#fb7185', // rose-400
            ];
            
            // Specific color mapping for common categories
            const categoryColorMap = {
                'edge': '#d8b4fe',     // purple-300
                'increase': '#86efac',  // green-300
                'main': '#93c5fd',     // blue-300
                'spine': '#f87171',    // red-300
            };
            
            // Generate CSS for each category
            let cssRules = '';
            const categoryArray = Array.from(categories);
            categoryArray.forEach((category, index) => {
                const color = categoryColorMap[category] || colorPalette[index % colorPalette.length];
                cssRules += `.${category} { color: ${color}; }\n`;
            });
            
            // Create and inject the dynamic stylesheet
            const styleElement = document.createElement('style');
            styleElement.id = 'pattern-theme';
            styleElement.textContent = cssRules;
            document.head.appendChild(styleElement);
            
            // Log the generated theme for debugging
            console.log('Generated pattern theme for categories:', categoryArray);
            console.log('CSS Rules:', cssRules);
        }
    }
    
    async function loadSelectedPattern(filename) {
        const patternNameEl = document.getElementById('pattern-name');
        const patternAuthorEl = document.getElementById('pattern-author');
        const patternContentEl = document.getElementById('pattern-content');
        
        try {
            patternNameEl.textContent = 'Loading...';
            // Add cache busting parameter to force reload
            const cacheBust = new Date().getTime();
            const response = await fetch(`/patterns/${filename}?v=${cacheBust}`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            PATTERN_DATA = await response.json();
            
            // Generate dynamic CSS for this pattern's categories
            generatePatternTheme();
            
            // Update UI with pattern info
            const { name, author, maxSteps: max } = PATTERN_DATA.metadata;
            patternNameEl.textContent = name;
            patternAuthorEl.textContent = `by ${author}`;
            maxSteps = max;
            document.getElementById('current-step-input').max = maxSteps;
            progressKey = `pattern-progress-${name.replace(/\s+/g, '-')}`;
            
            // Clear and regenerate content
            patternContentEl.innerHTML = '';
            generateGlossary();
            generateInstructions();
            loadProgress();
            
            footerControls.classList.remove('hidden');
        } catch (error) {
            console.error('Error loading pattern:', error);
            patternNameEl.textContent = 'Error Loading Pattern';
            patternAuthorEl.textContent = '';
            patternContentEl.innerHTML = `<p class="text-center text-red-400">Failed to load pattern: ${error.message}</p>`;
        }
    }
    
    function generatePatternTheme() {
        // Defensive check: ensure PATTERN_DATA is loaded
        if (!PATTERN_DATA || !PATTERN_DATA.instructions) {
            console.warn('generatePatternTheme called before PATTERN_DATA is fully loaded');
            return;
        }
        
        // Remove existing pattern theme
        const existingStyle = document.getElementById('pattern-theme');
        if (existingStyle) {
            existingStyle.remove();
        }
        
        // Collect all unique categories from the pattern
        const categories = new Set();
        
        try {
            PATTERN_DATA.instructions.forEach(instr => {
                if (instr.chunks && Array.isArray(instr.chunks)) {
                    instr.chunks.forEach(chunk => {
                        // Add category based on instruction type - defensive check
                        if (chunk && chunk.instruction) {
                            const category = getInstructionCategory(chunk.instruction);
                            categories.add(category);
                        }
                        // Also check repeat instructions
                        if (chunk && chunk.repeat && chunk.repeat.instructions && Array.isArray(chunk.repeat.instructions)) {
                            chunk.repeat.instructions.forEach(repeatInstr => {
                                if (repeatInstr && repeatInstr.instruction) {
                                    const category = getInstructionCategory(repeatInstr.instruction);
                                    categories.add(category);
                                }
                            });
                        }
                    });
                }
        });
        
        } catch (error) {
            console.error('Error generating pattern theme:', error);
            // Add some default categories if processing fails
            categories.add('main');
            categories.add('edge');
        }
        
        // Add standard categories for dynamic chunks
        categories.add('edge');
        categories.add('main');  
        categories.add('increase');
        categories.add('spine');
        
        // Default color palette
        const colorPalette = [
            '#d8b4fe', // purple-300 (edge/structural)
            '#86efac', // green-300 (increases)  
            '#93c5fd', // blue-300 (main/body)
            '#f87171', // red-300 (spine/center)
            '#fcd34d', // yellow-300 (lace-1)
            '#f9a8d4', // pink-300 (lace-2) 
            '#a7f3d0', // emerald-300 (lace-3)
            '#c4b5fd', // violet-300
            '#fbbf24', // amber-400
            '#34d399', // emerald-400
            '#60a5fa', // blue-400
            '#f472b6', // pink-400
            '#a78bfa', // violet-400
            '#fb7185', // rose-400
        ];
        
        // Specific color mapping for common categories
        const categoryColorMap = {
            'edge': '#d8b4fe',     // purple-300
            'increase': '#86efac',  // green-300
            'main': '#93c5fd',     // blue-300
            'spine': '#f87171',    // red-300
        };
        
        // Generate CSS for each category
        let cssRules = '';
        const categoryArray = Array.from(categories);
        categoryArray.forEach((category, index) => {
            const color = categoryColorMap[category] || colorPalette[index % colorPalette.length];
            cssRules += `.${category} { color: ${color}; }\n`;
        });
        
        // Create and inject the dynamic stylesheet
        const styleElement = document.createElement('style');
        styleElement.id = 'pattern-theme';
        styleElement.textContent = cssRules;
        document.head.appendChild(styleElement);
        
        // Log the generated theme for debugging
        console.log('Generated pattern theme for categories:', categoryArray);
        console.log('CSS Rules:', cssRules);
    }

    // --- GENERATOR LOGIC (Your existing functions) ---
    const patternTypeSelector=document.getElementById('pattern-type-selector');const imageInstructions=document.getElementById('image-instructions');const patternInput=document.getElementById('pattern-input');const promptOutput=document.getElementById('prompt-output');const copyButton=document.getElementById('copy-prompt-button');
    const basePrompt=`# AI Prompt: Convert a Craft Pattern to a Smartly Grouped JSON

## 1. The Goal & Persona

You are an expert technical editor for fiber arts (knitting, crochet, Tunisian crochet) and a software developer. Your task is to convert a human-readable pattern into a strict, **craft-agnostic**, and efficiently grouped JSON format for a web application.

## 2. The Input Pattern

\`\`\`
{{PATTERN_TEXT}}
\`\`\`

## 3. The Required JSON Output Structure
... (Full prompt text) ...

## 4. Detailed Instructions for Generating the \`instructions\` Array
... (Full prompt text) ...`;
    function updatePrompt(){const patternText=patternInput.value.trim();if(patternText){const fullPrompt=basePrompt.replace('{{PATTERN_TEXT}}',patternText);promptOutput.textContent=fullPrompt;}else{promptOutput.textContent='Paste pattern text to generate the prompt.';}}
    patternTypeSelector.addEventListener('click',(e)=>{if(e.target.tagName==='BUTTON'){const type=e.target.dataset.type;patternTypeSelector.querySelectorAll('button').forEach(btn=>btn.classList.remove('active'));e.target.classList.add('active');if(type==='image'){imageInstructions.classList.remove('hidden');}else{imageInstructions.classList.add('hidden');}}});
    patternInput.addEventListener('input',updatePrompt);
    copyButton.addEventListener('click',()=>{const textToCopy=promptOutput.textContent;navigator.clipboard.writeText(textToCopy).then(()=>{const defaultSpan=document.getElementById('copy-default');const successSpan=document.getElementById('copy-success');defaultSpan.classList.add('hidden');successSpan.classList.remove('hidden');setTimeout(()=>{defaultSpan.classList.remove('hidden');successSpan.classList.add('hidden');},2000);}).catch(err=>{console.error('Failed to copy text: ',err);});});

    // --- PWA Service Worker ---
    // Temporarily disabled to fix caching issues during development
    // if('serviceWorker' in navigator){window.addEventListener('load',()=>{navigator.serviceWorker.register('/sw.js').then(reg=>console.log('SW registered.')).catch(err=>console.log('SW registration failed: ',err));});}
</script>
</body>
</html>

