<!DOCTYPE html>
<!-- Version: v2025-10-02- Separating js -->
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stitch Witch - Separating JS v2025-10-02</title>
    <link rel="icon" type="image/png" href="/assets/icons/yarn-ball-icon.png">
    <link rel="shortcut icon" type="image/png" href="/assets/icons/yarn-ball-icon.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#8b5cf6">

    <!-- Tailwind CSS CDN - for development/demo purposes -->
    <!-- TODO: Replace with PostCSS build for production to improve performance -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        /* CSS Custom Properties for Dynamic Pattern-Based Theming */
        /* Colors will be dynamically injected by generatePatternTheme() */
        :root {
            /* Default fallback colors - will be overridden dynamically */
            --color-main: #93c5fd;
            --color-increase: #86efac;
            --color-decrease: #f87171;
            --color-edge: #d8b4fe;
            --color-spine: #f87171;
            --color-bobble: #fbbf24;
            --color-lace: #fb7185;
            --color-cable: #60a5fa;
            --color-texture: #fcd34d;
            --color-stitch: #a78bfa;
            --color-special: #34d399;
            --color-marker: #ff9800;
            --color-repeat: #ff6b6b;
            --color-bind: #9ca3af;
            --color-cast: #9ca3af;
        }

        body { font-family: 'Inter', sans-serif; background-color: #111827; color: #d1d5db; transition: all 0.3s ease; }
        
        /* Light mode styling */
        [data-theme="light"] body {
            background-color: #ffffff;
            color: #1f2937;
        }
        
        /* Light mode overrides for all dark elements */
        [data-theme="light"] .text-white { color: #1f2937 !important; }
        [data-theme="light"] .text-gray-300 { color: #4b5563 !important; }
        [data-theme="light"] .text-gray-400 { color: #6b7280 !important; }
        [data-theme="light"] .text-gray-500 { color: #9ca3af !important; }
        [data-theme="light"] .text-violet-300 { color: #7c3aed !important; }
        
        /* Light mode backgrounds */
        [data-theme="light"] .bg-gray-900 { background-color: #ffffff !important; }
        [data-theme="light"] .bg-gray-800 { background-color: #f8fafc !important; }
        [data-theme="light"] .bg-gray-700 { background-color: #e2e8f0 !important; }
        [data-theme="light"] .bg-gray-600 { background-color: #cbd5e1 !important; }
        
        /* Light mode borders */
        [data-theme="light"] .border-gray-700 { border-color: #e5e7eb !important; }
        [data-theme="light"] .border-gray-600 { border-color: #d1d5db !important; }
        
        /* Light mode buttons and interactive elements */
        [data-theme="light"] .bg-violet-600 { background-color: #7c3aed !important; }
        [data-theme="light"] .bg-blue-600 { background-color: #2563eb !important; }
        [data-theme="light"] .bg-green-600 { background-color: #059669 !important; }
        [data-theme="light"] .bg-red-600 { background-color: #dc2626 !important; }
        
        /* Light mode hover states */
        [data-theme="light"] .hover\\:bg-gray-700:hover { background-color: #f1f5f9 !important; }
        [data-theme="light"] .hover\\:bg-violet-700:hover { background-color: #6d28d9 !important; }
        [data-theme="light"] .hover\\:bg-blue-700:hover { background-color: #1d4ed8 !important; }
        [data-theme="light"] .hover\\:bg-green-700:hover { background-color: #047857 !important; }
        [data-theme="light"] .hover\\:bg-red-700:hover { background-color: #b91c1c !important; }
        
        /* Light mode form elements */
        [data-theme="light"] input, [data-theme="light"] select, [data-theme="light"] textarea {
            background-color: #ffffff !important;
            color: #1f2937 !important;
            border-color: #d1d5db !important;
        }
        
        /* Light mode code blocks */
        [data-theme="light"] .code-block {
            background-color: #f8fafc !important;
            border-color: #e5e7eb !important;
            color: #374151 !important;
        }
        
        /* Light mode result chunks */
        [data-theme="light"] .result-chunk {
            background-color: #f1f5f9 !important;
            color: #374151 !important;
        }
        
        .mono { font-family: 'Roboto Mono', monospace; }
        /* PERFORMANCE OPTIMIZED: Use CSS classes instead of inline styles for step highlighting */
        .current-step { 
            background-color: rgba(139, 92, 246, 0.3) !important; 
            border-radius: 0.5rem !important;
            padding: 0.75rem !important;
            margin: 0.25rem 0 !important;
            border: 2px solid rgba(139, 92, 246, 0.5) !important;
        }
        .previous-step {
            border: 1px solid rgba(139, 92, 246, 0.3) !important;
            border-radius: 0.25rem !important;
            padding: 0.25rem !important;
            margin: 0.125rem 0 !important;
        }
        [data-theme="light"] .current-step { 
            background-color: rgba(139, 92, 246, 0.2) !important; 
        }
        .pattern-text p { 
            padding: 0.5rem 0.75rem; 
            margin-bottom: 0.25rem; 
            transition: background-color 0.3s; 
        }
        /* Dynamic pattern-specific colors will be injected here */
        .highlight { background-color: #E6E6FA; color: #1a1a2e; padding: 2px 4px; border-radius: 3px; font-weight: bold; }
        [data-theme="light"] .highlight { background-color: #ddd6fe; color: #1f2937; }
        .result-chunk { background-color: #374151; padding: 1em; border-radius: 5px; color: #e0e0e0; overflow-x: auto; white-space: pre; }
        #stitch-locator-ui { transition: opacity 0.3s ease-in-out; }
        .tooltip { visibility: hidden; opacity: 0; transition: opacity 0.2s; position: absolute; z-index: 10; bottom: 125%; left: 50%; transform: translateX(-50%); padding: 0.5rem 1rem; border-radius: 0.375rem; background-color: #1f2937; color: #d1d5db; font-size: 0.875rem; white-space: nowrap; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .tooltip-trigger:hover .tooltip { visibility: visible; opacity: 1; }
        .tooltip::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #1f2937 transparent transparent transparent; }
        .tab-button { padding: 0.5rem 1rem; border-radius: 6px; font-weight: 500; cursor: pointer; transition: all 0.2s; border: 1px solid transparent; }
        .tab-button.active { background-color: #8b5cf6; color: white; }
        .tab-button:not(.active):hover { background-color: #4a5568; }
        .code-block { background-color: #1f2937; border: 1px solid #374151; border-radius: 8px; padding: 1rem; overflow-x: auto; font-family: 'Roboto Mono', monospace; font-size: 0.875rem; line-height: 1.6; color: #d1d5db; }
        .stitch-clickable { cursor: pointer; text-decoration: underline; text-decoration-style: dotted; transition: opacity 0.2s; }
        .stitch-clickable:hover { opacity: 0.8; }
        .bobble { color: #fbbf24 !important; font-weight: 600; }
        /* Stitch Color Classes - Using CSS Custom Properties */
        .main { color: var(--color-main) !important; font-weight: 400; }
        .increase { color: var(--color-increase) !important; font-weight: 500; }
        .decrease { color: var(--color-decrease) !important; font-weight: 500; }
        .edge { color: var(--color-edge) !important; font-weight: 500; }
        .spine { color: var(--color-spine) !important; font-weight: 600; }
        .bobble { color: var(--color-bobble) !important; font-weight: 600; }
        .lace { color: var(--color-lace) !important; font-weight: 500; }
        .cable { color: var(--color-cable) !important; font-weight: 600; }
        .texture { color: var(--color-texture) !important; font-weight: 500; }
        .stitch { color: var(--color-stitch) !important; font-weight: 400; }
        .special { color: var(--color-special) !important; font-weight: 600; }
        .marker { color: var(--color-marker) !important; font-weight: 500; }
        .repeat { color: var(--color-repeat) !important; font-weight: 500; }
        .bind { color: var(--color-bind) !important; font-weight: 500; }
        .cast { color: var(--color-cast) !important; font-weight: 500; }
        
        /* Color classes for sidebar use */
        .color-main { color: var(--color-main) !important; }
        .color-increase { color: var(--color-increase) !important; }
        .color-decrease { color: var(--color-decrease) !important; }
        .color-edge { color: var(--color-edge) !important; }
        .color-spine { color: var(--color-spine) !important; }
        .color-bobble { color: var(--color-bobble) !important; }
        .color-lace { color: var(--color-lace) !important; }
        .color-cable { color: var(--color-cable) !important; }
        .color-texture { color: var(--color-texture) !important; }
        .color-stitch { color: var(--color-stitch) !important; }
        .color-special { color: var(--color-special) !important; }
        .color-marker { color: var(--color-marker) !important; }
        .color-repeat { color: var(--color-repeat) !important; }
        .color-bind { color: var(--color-bind) !important; }
        .color-cast { color: var(--color-cast) !important; }
        
        .stitch-clickable { cursor: pointer; text-decoration: underline; text-decoration-style: dotted; transition: opacity 0.2s; }
        .stitch-clickable:hover { opacity: 0.8; }
        
        /* Sidebar Styles */
        #pattern-sidebar {
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
        }
        #pattern-sidebar.open {
            transform: translateX(0);
        }
        
        /* Better modal positioning */
        .modal-content {
            max-height: 80vh;
            overflow-y: auto;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-300 antialiased selection:bg-violet-500 selection:text-white">

    <!-- Sidebar Toggle Button -->
    <button id="sidebar-toggle" class="fixed top-4 left-4 z-[70] bg-gray-800 text-white p-3 rounded-full shadow-lg border border-gray-700 hover:bg-gray-700 transition-colors">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
    </button>

    <!-- Sidebar Overlay -->
    <div id="sidebar-overlay" class="fixed inset-0 bg-black bg-opacity-20 z-50 hidden"></div>

    <!-- Pattern Tools Sidebar -->
    <aside id="pattern-sidebar" class="fixed top-0 left-0 h-full w-80 bg-gray-800 border-r border-gray-700 p-6 z-[60] overflow-y-auto">
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-bold text-white">Pattern Tools</h2>
            <button id="sidebar-close" class="text-gray-400 hover:text-white text-2xl">&times;</button>
        </div>
        
        <div class="space-y-6">
            <!-- Return to Current Row -->
            <div>
                <button id="return-to-row" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition-colors">
                    Return to Current Row
                </button>
            </div>

            <!-- Jump to Section -->
            <div>
                <h3 class="text-lg font-semibold text-gray-300 mb-3">Jump to Section</h3>
                <div class="space-y-2 text-sm">
                    <div class="sidebar-links">
                        <a href="#" data-section="section1" class="block text-blue-400 hover:text-blue-300 py-1">Section 1: Increasing</a>
                        <a href="#" data-section="section2" class="block text-blue-400 hover:text-blue-300 py-1">Section 2: Decreasing</a>
                    </div>
                </div>
            </div>

            <!-- Color Key -->
            <div>
                <h3 class="text-lg font-semibold text-gray-300 mb-3">Color Key</h3>
                <div id="sidebar-color-key" class="space-y-2 text-sm">
                    <!-- Will be populated dynamically from pattern data -->
                </div>
            </div>

            <!-- Materials & Notes -->
            <div>
                <h3 class="text-lg font-semibold text-gray-300 mb-3">Materials & Notes</h3>
                <div class="text-sm text-gray-400 space-y-1">
                    <div>Yarn: Pattern specific</div>
                    <div>Needles: As specified</div>
                    <div>Gauge: Pattern specific</div>
                </div>
            </div>

            <!-- Stitch Glossary -->
            <div>
                <h3 class="text-lg font-semibold text-gray-300 mb-3">Stitch Glossary</h3>
                <div id="sidebar-glossary" class="text-sm space-y-2">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </aside>

    <!-- Standalone Generator: Always accessible -->
    <div id="standalone-generator" class="hidden max-w-5xl mx-auto p-4 sm:p-6 lg:p-8">
        <header class="flex justify-between items-center mb-8 border-b border-gray-700 pb-4">
            <h1 class="text-3xl font-bold text-white">Pattern Tools</h1>
            <div class="flex space-x-2">
                <a href="pattern-upload.html" class="bg-purple-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-purple-700 transition-colors">
                    <i class="fas fa-upload mr-2"></i>Upload Pattern
                </a>
                <button id="back-to-main" class="bg-violet-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-violet-700 transition-colors">Back to Hub</button>
            </div>
        </header>
        
        <div class="grid gap-6 md:grid-cols-2">
            <div class="bg-gray-800 p-6 rounded-xl shadow-lg">
                <h2 class="text-xl font-bold text-white mb-4">Upload Pattern</h2>
                <p class="text-gray-400 mb-4">Upload your own JSON patterns to use in the pattern viewer.</p>
                <a href="pattern-upload.html" class="block bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg text-center transition-colors">
                    <i class="fas fa-upload mr-2"></i>Go to Upload Page
                </a>
            </div>
            <div class="bg-gray-800 p-6 rounded-xl shadow-lg">
                <h2 class="text-xl font-bold text-white mb-4">AI Generator</h2>
                <p class="text-gray-400 mb-4">Generate patterns from text descriptions using AI.</p>
                <button class="w-full bg-gray-600 text-white font-bold py-3 px-6 rounded-lg cursor-not-allowed" disabled>
                    <i class="fas fa-magic mr-2"></i>Coming Soon
                </button>
            </div>
        </div>
    </div>

    <!-- Auth Container: Shown when logged out -->
    <div id="auth-container" class="min-h-screen flex items-center justify-center">
        <div class="text-center p-8 bg-gray-800 rounded-xl shadow-2xl border border-gray-700 max-w-md mx-auto">
            <div class="mb-6">
                <div class="w-16 h-16 bg-violet-600 rounded-full flex items-center justify-center mx-auto mb-4">
                    <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3z"/>
                    </svg>
                </div>
                <h1 class="text-3xl font-bold text-white mb-2">Welcome Back</h1>
                <p class="text-gray-400">Sign in to access your pattern library</p>
            </div>
            
            <button id="login-btn" class="w-full bg-violet-600 text-white font-bold py-4 px-6 rounded-lg hover:bg-violet-700 transition-colors flex items-center justify-center">
                <svg class="w-6 h-6 mr-3" viewBox="0 0 48 48">
                    <path fill="#FFC107" d="M43.611 20.083H42V20H24v8h11.303c-1.649 4.657-6.08 8-11.303 8c-6.627 0-12-5.373-12-12s5.373-12 12-12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C12.955 4 4 12.955 4 24s8.955 20 20 20s20-8.955 20-20c0-1.341-.138-2.65-.389-3.917z"></path>
                    <path fill="#FF3D00" d="m6.306 14.691l6.571 4.819C14.655 15.108 18.961 12 24 12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C16.318 4 9.656 8.337 6.306 14.691z"></path>
                    <path fill="#4CAF50" d="M24 44c5.166 0 9.86-1.977 13.409-5.192l-6.19-5.238C29.211 35.091 26.715 36 24 36c-5.222 0-9.618-3.317-11.28-7.962l-6.522 5.025C9.505 39.556 16.227 44 24 44z"></path>
                    <path fill="#1976D2" d="M43.611 20.083H42V20H24v8h11.303c-.792 2.237-2.231 4.166-4.087 5.571l6.19 5.238C44.572 36.801 48 30.853 48 24c0-1.341-.138-2.65-.389-3.917z"></path>
                </svg>
                Continue with Google
            </button>
            
            <div class="mt-6 pt-6 border-t border-gray-700">
                <p class="text-xs text-gray-500">
                    By signing in, you agree to our terms of service and privacy policy
                </p>
            </div>
        </div>
    </div>

    <!-- App Container: Shown when logged in -->
    <div id="app-container" class="hidden max-w-5xl mx-auto p-4 sm:p-6 lg:p-8">
        <header class="flex flex-col sm:flex-row justify-between items-center mb-8 border-b border-gray-700 pb-4">
            <div class="text-center sm:text-left mb-4 sm:mb-0">
                <h1 class="text-3xl font-bold text-white">Pattern Hub</h1>
                <p id="user-display" class="text-sm text-gray-400">Welcome!</p>
                <p class="text-xs text-gray-500">v2025-10-02 - Fixed pattern loading & progress collection</p>
            </div>
            <div class="flex items-center space-x-4">
                 <nav id="app-nav" class="flex items-center space-x-2 bg-gray-800 p-1 rounded-lg">
                    <button data-view="viewer" class="tab-button active">Viewer</button>
                    <button id="generator-nav-btn" class="bg-green-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-green-700 transition-colors text-sm">Generator</button>
                </nav>
                <!-- DEVELOPMENT BUTTONS - HIDDEN IN PRODUCTION -->
                <!-- <button id="create-sample-progress-btn" class="bg-yellow-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-yellow-700 transition-colors text-sm">Create Sample Progress</button> -->
                <!-- <button id="recreate-progress-collection-btn" class="bg-purple-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-purple-700 transition-colors text-sm">Recreate Progress Collection</button> -->
                <button id="logout-btn" class="bg-red-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-red-700 transition-colors text-sm">Sign Out</button>
            </div>
        </header>

        <!-- VIEWER SECTION -->
        <div id="viewer-section">
            <header class="text-center mb-8">
                <!-- PROJECT MANAGER -->
                <div class="mb-6">
                    <div class="flex items-center justify-center space-x-4 mb-4">
                        <div class="flex-1 max-w-lg">
                            <label for="project-selector" class="block text-sm font-medium text-gray-300 mb-2">My Projects:</label>
                            <select id="project-selector" class="w-full bg-gray-800 border border-gray-600 text-white rounded-lg px-4 py-2 focus:ring-2 focus:ring-violet-500 focus:border-violet-500">
                                <option value="">Loading your projects...</option>
                            </select>
                        </div>
                        <div class="flex space-x-2">
                            <button id="new-project-btn" class="bg-emerald-600 hover:bg-emerald-700 text-white px-4 py-2 rounded-lg text-sm transition-colors" title="Start New Project">
                                ‚ûï New
                            </button>
                            <button id="delete-project-btn" class="bg-orange-600 hover:bg-orange-700 text-white px-4 py-2 rounded-lg text-sm transition-colors" disabled title="Archive or Permanently Delete Project">
                                üóÉÔ∏è Archive
                            </button>
                            <button id="show-archived-btn" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg text-sm transition-colors" title="View Archived Projects">
                                üì¶ Archived
                            </button>
                        </div>
                    </div>
                    
                    <!-- PROJECT INFO DISPLAY -->
                    <div id="project-info" class="hidden">
                        <h2 id="project-name" class="text-3xl font-bold text-white mb-2"></h2>
                        <p id="project-pattern-info" class="text-lg text-violet-300 mb-2"></p>
                        
                        <!-- PATTERN INFORMATION -->
                        <div class="mb-4 text-center">
                            <h3 id="pattern-name" class="text-2xl font-bold text-emerald-400 mb-1">Pattern Name</h3>
                            <p id="pattern-author" class="text-lg text-gray-300">by Pattern Author</p>
                        </div>
                        
                        <div id="project-details" class="mt-3 p-4 bg-gray-800 rounded-lg border border-gray-600">
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                                <div><span class="text-gray-400">Pattern:</span> <span id="project-pattern-name" class="text-white"></span></div>
                                <div><span class="text-gray-400">Started:</span> <span id="project-start-date" class="text-white"></span></div>
                                <div><span class="text-gray-400">Last Updated:</span> <span id="project-last-update" class="text-white"></span></div>
                            </div>
                            <div class="mt-3 pt-3 border-t border-gray-700">
                                <div class="text-sm text-gray-400">Progress: <span id="project-progress-summary" class="text-violet-300"></span></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- NO PROJECT STATE -->
                    <div id="no-project-state" class="text-center py-8">
                        <h2 class="text-3xl font-bold text-white mb-4">Welcome to Stitch Witch! ‚ú®</h2>
                        <p class="text-lg text-gray-300 mb-6">Create your first project to start tracking your crafting journey with patterns from our Firestore database</p>
                        <button id="welcome-new-project-btn" class="bg-emerald-600 hover:bg-emerald-700 text-white px-6 py-3 rounded-lg text-lg transition-colors">
                            ‚ûï Start Your First Project
                        </button>
                    </div>
                </div>
            </header>
            <main id="pattern-content" class="space-y-8 pb-40"></main>
            <div id="stitch-popup" class="hidden fixed bg-gray-700 p-6 rounded-lg shadow-2xl z-50 border border-violet-500 w-11/12 max-w-md">
                <button id="close-popup-btn" class="absolute top-2 right-3 text-2xl text-gray-400 hover:text-white">&times;</button>
                <div id="popup-content"></div>
            </div>
        </div>
        
        <!-- PROJECT NOTES SIDEBAR -->
        <div id="notes-sidebar" class="fixed right-0 top-0 h-full w-96 bg-gray-900 border-l border-gray-700 transform translate-x-full transition-transform duration-300 ease-in-out z-40 overflow-y-auto">
            <div class="p-4">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-lg font-bold text-white">Project Notes</h3>
                    <button id="close-notes-sidebar" class="text-gray-400 hover:text-white">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <!-- General Notes -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-300 mb-2">General Notes</label>
                    <textarea id="general-notes" class="w-full h-24 bg-gray-800 border border-gray-600 text-white rounded px-3 py-2 resize-none" placeholder="General project notes..."></textarea>
                </div>
                
                <!-- Current Row Note -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-300 mb-2">Row <span id="current-row-note-label">1</span> Note</label>
                    <textarea id="current-row-note" class="w-full h-20 bg-gray-800 border border-gray-600 text-white rounded px-3 py-2 resize-none" placeholder="Note for current row..."></textarea>
                    <button id="save-row-note" class="mt-2 bg-violet-600 hover:bg-violet-700 text-white px-3 py-1 rounded text-sm">Save Row Note</button>
                </div>
                
                <!-- Yarn Details -->
                <div class="mb-6">
                    <h4 class="text-md font-medium text-gray-300 mb-3">Yarn & Materials</h4>
                    <div class="space-y-3">
                        <div>
                            <label class="block text-xs text-gray-400 mb-1">Yarn Brand & Color</label>
                            <input id="yarn-info" type="text" class="w-full bg-gray-800 border border-gray-600 text-white rounded px-2 py-1 text-sm" placeholder="e.g., Red Heart Soft Navy">
                        </div>
                        <div>
                            <label class="block text-xs text-gray-400 mb-1">Needle/Hook Size</label>
                            <input id="tool-info" type="text" class="w-full bg-gray-800 border border-gray-600 text-white rounded px-2 py-1 text-sm" placeholder="e.g., US 6 (4.0mm)">
                        </div>
                        <div>
                            <label class="block text-xs text-gray-400 mb-1">Modifications</label>
                            <textarea id="modifications" class="w-full h-16 bg-gray-800 border border-gray-600 text-white rounded px-2 py-1 text-sm resize-none" placeholder="Pattern modifications..."></textarea>
                        </div>
                    </div>
                </div>
                
                <!-- Row Notes List -->
                <div class="mb-6">
                    <h4 class="text-md font-medium text-gray-300 mb-3">All Row Notes</h4>
                    <div id="row-notes-list" class="space-y-2 max-h-40 overflow-y-auto">
                        <!-- Row notes will be populated here -->
                    </div>
                </div>
                
                <button id="save-all-notes" class="w-full bg-green-600 hover:bg-green-700 text-white py-2 rounded">Save All Notes</button>
            </div>
        </div>

        <!-- GENERATOR SECTION -->
        <div id="generator-section" class="hidden bg-gray-800 p-6 sm:p-8 rounded-xl shadow-lg">
            <h2 class="text-2xl font-bold text-white mb-6 border-b border-gray-700 pb-4">AI Prompt Generator</h2>
            <div class="space-y-8">
                <div>
                    <h3 class="text-lg font-semibold text-gray-300 mb-3">Step 1: Choose Pattern Format</h3>
                    <div id="pattern-type-selector" class="flex items-center space-x-2 bg-gray-700 p-1 rounded-lg max-w-xs">
                        <button data-type="text" class="w-1/2 tab-button active">Text</button>
                        <button data-type="image" class="w-1/2 tab-button">Image</button>
                    </div>
                    <div id="image-instructions" class="hidden mt-4 p-4 bg-yellow-900 bg-opacity-30 border border-yellow-700 rounded-lg text-yellow-300">
                        <h4 class="font-semibold mb-2">Image-Based Pattern Workflow</h4>
                        <ol class="list-decimal list-inside mt-2 space-y-1 text-sm">
                            <li><strong>Transcribe Image:</strong> Use an AI with vision. Prompt: <span class="mono text-xs bg-gray-900 p-1 rounded">"Please transcribe the text from this image of a pattern."</span></li>
                            <li><strong>Generate JSON:</strong> Paste the transcribed text into Step 2 below.</li>
                        </ol>
                    </div>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-gray-300 mb-3">Step 2: Paste Pattern Text</h3>
                    <textarea id="pattern-input" rows="8" class="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-gray-300 focus:ring-2 focus:ring-violet-500 focus:border-violet-500 transition" placeholder="Paste pattern text here..."></textarea>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-gray-300 mb-3">Step 3: Generate and Copy AI Prompt</h3>
                    <div class="relative">
                        <button id="copy-prompt-button" class="absolute top-3 right-3 bg-gray-600 hover:bg-gray-500 text-white font-medium py-1 px-3 border border-gray-500 rounded-md text-sm transition-colors">
                            <span id="copy-default">Copy</span>
                            <span id="copy-success" class="hidden">Copied!</span>
                        </button>
                        <div id="prompt-output" class="code-block h-64 overflow-y-auto">Paste pattern text to generate the prompt.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="fixed bottom-0 left-0 right-0 bg-gray-900 bg-opacity-80 backdrop-blur-sm border-t border-gray-700 p-4">
        <div id="footer-controls" class="max-w-4xl mx-auto hidden">
            <!-- Pattern Metadata -->
            <div id="pattern-metadata" class="text-center mb-2">
                <div class="text-sm text-gray-400">
                    <span id="current-pattern-name" class="text-violet-300 font-medium">No pattern selected</span>
                    <span class="mx-2">‚Ä¢</span>
                    <span id="pattern-progress-info">Row <span id="footer-current-step">1</span> of <span id="footer-max-steps">1</span></span>
                </div>
            </div>
            
            <div class="relative h-20">
                <div id="step-counter-ui" class="absolute inset-0 flex items-center justify-between transition-opacity duration-300">
                    <!-- Left Side Controls -->
                    <div class="flex items-center space-x-2">
                        <!-- Theme Toggle Button -->
                        <button id="theme-toggle" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-lg transition-colors flex items-center" title="Toggle light/dark mode">
                            <svg id="theme-icon-dark" class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path>
                            </svg>
                            <svg id="theme-icon-light" class="w-5 h-5 hidden" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="hidden lg:inline text-xs ml-1">Theme</span>
                        </button>
                        
                        <!-- Jump to Start Button -->
                        <button id="jump-to-start" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-lg transition-colors flex items-center" title="Jump to row 1">
                            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M15.707 15.707a1 1 0 01-1.414 0l-5-5a1 1 0 010-1.414l5-5a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 010 1.414zm-6 0a1 1 0 01-1.414 0l-5-5a1 1 0 010-1.414l5-5a1 1 0 011.414 1.414L5.414 10l4.293 4.293a1 1 0 010 1.414z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="hidden lg:inline text-xs ml-1">Start</span>
                        </button>
                    </div>
                    
                    <!-- Row Counter Section -->
                    <div class="flex items-center space-x-6">
                        <button id="prev-step" class="w-14 h-14 bg-violet-600 text-white font-bold rounded-full text-3xl flex items-center justify-center shadow-lg hover:bg-violet-700 focus:outline-none focus:ring-2 focus:ring-violet-400 focus:ring-opacity-75 transition-transform transform active:scale-95">-</button>
                        <div class="text-center">
                            <div id="step-type" class="text-sm text-gray-400">ROW</div>
                            <input type="number" id="current-step-input" min="1" class="text-4xl font-bold text-white bg-transparent text-center w-28 focus:outline-none focus:ring-2 focus:ring-violet-500 rounded-lg">
                        </div>
                        <button id="next-step" class="w-14 h-14 bg-violet-600 text-white font-bold rounded-full text-3xl flex items-center justify-center shadow-lg hover:bg-violet-700 focus:outline-none focus:ring-2 focus:ring-violet-400 focus:ring-opacity-75 transition-transform transform active:scale-95">+</button>
                    </div>
                    
                    <!-- Right Side Controls -->
                    <div class="flex items-center space-x-2">
                        <!-- Add Note Button -->
                        <button id="add-note" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-3 rounded-lg transition-colors flex items-center" title="Add note for current row">
                            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z"></path>
                            </svg>
                            <span class="hidden lg:inline text-xs ml-1">Note</span>
                        </button>
                        
                        <!-- Notes Toggle Button -->
                        <button id="toggle-notes-sidebar" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-lg transition-colors flex items-center" title="View/Edit Project Notes">
                            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"></path>
                                <path fill-rule="evenodd" d="M4 5a2 2 0 012-2v1a1 1 0 001 1h6a1 1 0 001-1V3a2 2 0 012 2v6a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="hidden lg:inline text-xs ml-1">Notes</span>
                        </button>
                    </div>
                </div>
                <div id="stitch-locator-ui" class="absolute inset-0 flex items-center justify-center space-x-4 transition-opacity duration-300 opacity-0 pointer-events-none">
                    <label for="stitch-input" class="text-lg">Stitch #:</label>
                    <input type="number" id="stitch-input" min="1" class="bg-gray-700 text-white border border-violet-500 rounded-md p-2 w-24 text-center">
                    <button id="find-stitch-btn" class="bg-violet-600 text-white font-bold rounded-md py-2 px-4 hover:bg-violet-700">Find</button>
                </div>
            </div>
            <div class="text-center mt-2">
                <button id="toggle-mode" class="text-violet-300 hover:text-white text-sm">Switch to Stitch Locator</button>
            </div>
        </div>
    </footer>

    <!-- Stitch Definition Modal -->
    <div id="stitch-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-start justify-center p-4 pt-16 z-[70] hidden">
        <div class="bg-gray-800 text-gray-200 rounded-lg shadow-xl p-6 w-full max-w-md relative modal-content mx-4">
            <button id="close-stitch-modal" class="absolute top-2 right-3 text-gray-400 hover:text-white text-2xl font-bold">&times;</button>
            <h3 id="stitch-modal-title" class="text-2xl font-bold mb-4 text-white"></h3>
            <div id="stitch-modal-definition" class="text-gray-300 whitespace-pre-line"></div>
        </div>
    </div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithRedirect, getRedirectResult, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, collection, addDoc, serverTimestamp, query, where, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    
    // Import our modular functions
    import { getInstructionCategory } from "./js/utils.js";
    import { generateGlossary, generateInstructions, generatePatternTheme, updateSidebarColorKey } from "./js/pattern-functions.js";
    import { logStitchWitchQuery, createStitchFinderQuery, createNavigationQuery, getStitchContext } from "./js/stitch-witch.js";
    import { loadProgress, saveProgress, updateDisplay, findInstructionForStep, findStepElement, getStitchCount, loadProgressSimple, loadProgressFirestore, saveProgressFirestore } from "./js/viewer-logic.js";
    import { saveProjectProgress, getCurrentProject, getOrCreateProject } from "./js/progress-tracking.js";
    import { getCurrentStep, setCurrentStep, loadUserProgress, createNewProject } from "./js/progress-tracking.js";
    import { 
        signInWithGoogle, 
        signOutUser, 
        toggleNotesSidebar,
        loadProjectNotes,
        saveCurrentRowNote,
        addRowNoteIndicator,
        loadRowNoteIndicators,
        goToRowWithNote
    } from "./js/app-main.js";
    // Note: createSeaWitchPattern and setupProgressTracking are one-time setup scripts - no longer needed
    
    // --- CONFIG & STATE ---
    // For Firebase JS SDK v7.20.0 and later, measurementId is optional
    const firebaseConfig = {
    apiKey: "AIzaSyBmI_9qHr18VWclwzomAUElLTmgJ_MCI3g",
    authDomain: "arachne-edda2.firebaseapp.com",
    projectId: "arachne-edda2",
    storageBucket: "arachne-edda2.firebasestorage.app",
    messagingSenderId: "285468127259",
    appId: "1:285468127259:web:9a1285684a1a6b9b1548be",
    measurementId: "G-208TQKEXGG"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    
    // Make db globally available for analytics
    window.db = db;
    window.auth = auth;
    
    let PATTERN_DATA = null;
    let currentStep = 1, maxSteps = 1, progressKey = 'pattern-progress-default';
    let currentPatternId = null;
    let isStitchLocatorMode = false;
    let stitchCountsCache = {};
    let showArchivedProjects = false; // Track whether we're showing archived projects

    // --- UI ELEMENTS ---
    const authContainer = document.getElementById('auth-container');
    const appContainer = document.getElementById('app-container');
    const standaloneGenerator = document.getElementById('standalone-generator');
    const loginBtn = document.getElementById('login-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const generatorNavBtn = document.getElementById('generator-nav-btn');
    // const createSampleProgressBtn = document.getElementById('create-sample-progress-btn');
    // const recreateProgressCollectionBtn = document.getElementById('recreate-progress-collection-btn');
    const backToMainBtn = document.getElementById('back-to-main');
    const userDisplay = document.getElementById('user-display');
    const appNav = document.getElementById('app-nav');
    const viewerSection = document.getElementById('viewer-section');
    const generatorSection = document.getElementById('generator-section');
    const footerControls = document.getElementById('footer-controls');
    const patternSelector = document.getElementById('pattern-selector');
    
    let availablePatterns = [];

    // --- AUTHENTICATION ---
    const provider = new GoogleAuthProvider();
    
    // Force account selection and ensure we get fresh tokens
    provider.setCustomParameters({
        prompt: 'select_account'
    });
    
    async function signInWithGoogle() {
        console.log('=== LOGIN BUTTON CLICKED ===');
        console.log('Using redirect auth for better mobile compatibility...');
        console.log('Auth object:', auth);
        console.log('Provider object:', provider);
        
        try {
            loginBtn.disabled = true;
            loginBtn.innerHTML = `
                <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Redirecting to Google...
            `;
            
            console.log('Calling signInWithRedirect...');
            await signInWithRedirect(auth, provider);
            // Note: This will redirect the page, so code after this won't execute
            
        } catch (error) {
            console.log('‚ùå signInWithRedirect failed:');
            console.log('Error object:', error);
            console.log('Error code:', error.code);
            console.log('Error message:', error.message);
            
            alert('Sign in failed: ' + error.code + ' - ' + error.message);
            
            // Reset button
            loginBtn.disabled = false;
            loginBtn.innerHTML = `
                <svg class="w-6 h-6 mr-3" viewBox="0 0 48 48">
                    <path fill="#FFC107" d="M43.611 20.083H42V20H24v8h11.303c-1.649 4.657-6.08 8-11.303 8c-6.627 0-12-5.373-12-12s5.373-12 12-12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C12.955 4 4 12.955 4 24s8.955 20 20 20s20-8.955 20-20c0-1.341-.138-2.65-.389-3.917z"></path>
                    <path fill="#FF3D00" d="m6.306 14.691l6.571 4.819C14.655 15.108 18.961 12 24 12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C16.318 4 9.656 8.337 6.306 14.691z"></path>
                    <path fill="#4CAF50" d="M24 44c5.166 0 9.86-1.977 13.409-5.192l-6.19-5.238C29.211 35.091 26.715 36 24 36c-5.222 0-9.618-3.317-11.28-7.962l-6.522 5.025C9.505 39.556 16.227 44 24 44z"></path>
                    <path fill="#1976D2" d="M43.611 20.083H42V20H24v8h11.303c-.792 2.237-2.231 4.166-4.087 5.571l6.19 5.238C44.572 36.801 48 30.853 48 24c0-1.341-.138-2.65-.389-3.917z"></path>
                </svg>
                Continue with Google
            `;
        }
    }
    
    // Check for redirect result when page loads
    async function checkRedirectResult() {
        console.log('=== CHECKING REDIRECT RESULT ===');
        try {
            const result = await getRedirectResult(auth);
            if (result) {
                console.log('‚úÖ Found redirect result:', result);
                console.log('User from redirect:', result.user.email);
                // Don't need to do anything here - onAuthStateChanged will handle it
            } else {
                console.log('No redirect result found');
            }
        } catch (error) {
            console.error('‚ùå Error getting redirect result:', error);
            // Reset button if there was an error
            if (loginBtn) {
                loginBtn.disabled = false;
                loginBtn.innerHTML = `
                    <svg class="w-6 h-6 mr-3" viewBox="0 0 48 48">
                        <path fill="#FFC107" d="M43.611 20.083H42V20H24v8h11.303c-1.649 4.657-6.08 8-11.303 8c-6.627 0-12-5.373-12-12s5.373-12 12-12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C12.955 4 4 12.955 4 24s8.955 20 20 20s20-8.955 20-20c0-1.341-.138-2.65-.389-3.917z"></path>
                        <path fill="#FF3D00" d="m6.306 14.691l6.571 4.819C14.655 15.108 18.961 12 24 12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C16.318 4 9.656 8.337 6.306 14.691z"></path>
                        <path fill="#4CAF50" d="M24 44c5.166 0 9.86-1.977 13.409-5.192l-6.19-5.238C29.211 35.091 26.715 36 24 36c-5.222 0-9.618-3.317-11.28-7.962l-6.522 5.025C9.505 39.556 16.227 44 24 44z"></path>
                        <path fill="#1976D2" d="M43.611 20.083H42V20H24v8h11.303c-.792 2.237-2.231 4.166-4.087 5.571l6.19 5.238C44.572 36.801 48 30.853 48 24c0-1.341-.138-2.65-.389-3.917z"></path>
                    </svg>
                    Continue with Google
                `;
            }
        }
    }
    
    loginBtn.addEventListener('click', signInWithGoogle);

    generatorNavBtn.addEventListener('click', () => {
        showSection('generator');
    });
    
    backToMainBtn.addEventListener('click', () => {
        showSection('viewer');
    });
    
    // PROJECT MANAGEMENT EVENT HANDLERS
    const newProjectBtn = document.getElementById('new-project-btn');
    const welcomeNewProjectBtn = document.getElementById('welcome-new-project-btn');
    const deleteProjectBtn = document.getElementById('delete-project-btn');
    const showArchivedBtn = document.getElementById('show-archived-btn');
    
    newProjectBtn.addEventListener('click', showNewProjectModal);
    welcomeNewProjectBtn.addEventListener('click', showNewProjectModal);
    
    if (showArchivedBtn) {
        showArchivedBtn.addEventListener('click', toggleArchivedProjects);
    }
    
    deleteProjectBtn.addEventListener('click', async () => {
        const selector = document.getElementById('project-selector');
        if (!selector.value) {
            alert('Please select a project to delete.');
            return;
        }
        
        // Check if we're in archived view and this is an unarchive action
        if (showArchivedProjects) {
            // Unarchive the project
            const confirmation = confirm('Restore this project to your active projects list?');
            if (!confirmation) return;
            
            await unarchiveProject(selector.value);
            return;
        }
        
        // Show options for what to do with the project
        const action = confirm('What would you like to do with this project?\n\nOK = Archive (hide from list, keep all data for analytics)\nCancel = Permanently Delete (removes all historical data)');
        
        try {
            const userId = auth.currentUser.uid;
            const [patternId, projectId] = selector.value.split('_');
            
            // Construct the document ID directly
            const progressId = `${userId}_${patternId}_${projectId}`;
            
            console.log('ÔøΩÔ∏è Managing project:', { 
                userId, 
                patternId, 
                projectId, 
                progressId,
                action: action ? 'archive' : 'delete',
                selectorValue: selector.value 
            });
            
            // Check if document exists before trying to modify
            const docRef = doc(db, 'user_pattern_progress', progressId);
            const docSnapshot = await getDoc(docRef);
            
            if (!docSnapshot.exists()) {
                console.warn('‚ö†Ô∏è Document not found:', progressId);
                alert('Project not found. It may have already been deleted.');
                await populateProjectSelector(); // Refresh to show current state
                return;
            }
            
            if (action) {
                // Archive - preserve all data but mark as archived
                console.log('üîí Archiving project:', progressId);
                await updateDoc(docRef, {
                    status: 'archived',
                    archivedAt: serverTimestamp(),
                    archivedReason: 'user_request',
                    lastUpdated: serverTimestamp()
                });
                console.log('‚úÖ Project archived successfully');
                alert('Project archived! All progress data preserved but hidden from active projects.');
            } else {
                // Permanent delete - remove all historical data
                const confirmDelete = confirm('‚ö†Ô∏è PERMANENT DELETE WARNING ‚ö†Ô∏è\n\nThis will permanently remove ALL progress data, notes, photos, and analytics for this project. This cannot be undone.\n\nAre you absolutely sure?');
                if (!confirmDelete) return;
                
                console.log('üóëÔ∏è Permanently deleting project:', progressId);
                await deleteDoc(docRef);
                console.log('‚úÖ Project permanently deleted');
                alert('Project permanently deleted.');
            }
            console.log('‚úÖ All documents deleted successfully');
            
            // Clear current project selection
            window.currentProject = null;
            
            // Refresh project list
            await populateProjectSelector();
            
            console.log('‚úÖ Project deleted and UI refreshed:', projectId);
            alert('Project deleted successfully!');
        } catch (error) {
            console.error('‚ùå Error deleting project:', error);
            console.error('‚ùå Error details:', error.message, error.stack);
            alert(`Error deleting project: ${error.message}`);
        }
    });

    logoutBtn.addEventListener('click', () => {
        signOut(auth).catch(error => console.error("Sign out error", error));
    });

    // DEVELOPMENT BUTTON EVENT HANDLERS - COMMENTED OUT FOR PRODUCTION
    /*
    createSampleProgressBtn.addEventListener('click', async () => {
        try {
            createSampleProgressBtn.disabled = true;
            createSampleProgressBtn.textContent = 'Creating...';
            
            await createSampleUserPatternProgress();
            
            createSampleProgressBtn.textContent = 'Created!';
            createSampleProgressBtn.style.backgroundColor = '#059669'; // green
            
            setTimeout(() => {
                createSampleProgressBtn.disabled = false;
                createSampleProgressBtn.textContent = 'Create Sample Progress';
                createSampleProgressBtn.style.backgroundColor = '#d97706'; // yellow
            }, 2000);
            
        } catch (error) {
            console.error('Error creating sample progress:', error);
            alert('Error creating sample progress: ' + error.message);
            createSampleProgressBtn.disabled = false;
            createSampleProgressBtn.textContent = 'Create Sample Progress';
        }
    });

    recreateProgressCollectionBtn.addEventListener('click', async () => {
        try {
            recreateProgressCollectionBtn.disabled = true;
            recreateProgressCollectionBtn.textContent = 'Recreating...';
            
            await recreateUserPatternProgressCollection();
            
            recreateProgressCollectionBtn.textContent = 'Recreated!';
            recreateProgressCollectionBtn.style.backgroundColor = '#059669'; // green
            
            setTimeout(() => {
                recreateProgressCollectionBtn.disabled = false;
                recreateProgressCollectionBtn.textContent = 'Recreate Progress Collection';
                recreateProgressCollectionBtn.style.backgroundColor = '#7c3aed'; // purple
            }, 2000);
            
        } catch (error) {
            console.error('Error recreating progress collection:', error);
            alert('Error recreating progress collection: ' + error.message);
            recreateProgressCollectionBtn.disabled = false;
            recreateProgressCollectionBtn.textContent = 'Recreate Progress Collection';
        }
    });
    */

    // --- AUTHORIZATION & APP STATE ---
    
    function showNotAuthorized(user) {
        authContainer.classList.add('hidden');
        appContainer.classList.remove('hidden');
        userDisplay.textContent = `Access Denied for ${user.email}`;
        viewerSection.innerHTML = `<div class="text-center p-8 bg-gray-800 rounded-lg"><h2 class="text-2xl font-bold text-red-400">Not Authorized</h2><p class="text-gray-400 mt-2">Your account does not have permission to view this content.</p></div>`;
        generatorSection.classList.add('hidden');
        footerControls.classList.add('hidden');
    }

    function showApplication(user, userData = null, roleData = null) {
        try {
            authContainer.classList.add('hidden');
            appContainer.classList.remove('hidden');
            
            // Display user info with role
            const roleName = roleData ? roleData.name : 'User';
            userDisplay.textContent = `${user.displayName || user.email} (${roleName})`;
            
            console.log('Initializing application for user:', user.email);
            console.log('User role:', userData?.role);
            console.log('User permissions:', roleData?.permissions);
            
            // Store user data globally for use in other parts of the app
            window.currentUser = user;
            window.currentUserData = userData;
            window.currentUserRole = roleData;
            
            // Load user projects since Firestore is already initialized
            populateProjectSelector().then(() => {
                console.log('Projects loaded, initializing viewer');
                initializeViewer();
            }).catch(error => {
                console.error('Error during project loading or viewer initialization:', error);
            });
        } catch (error) {
            console.error('Error in showApplication:', error);
        }
    }

    // Create sample user pattern progress entry for testing
    async function createSampleUserPatternProgress() {
        if (!auth.currentUser) {
            throw new Error('User not authenticated');
        }

        if (!window.PATTERN_DATA) {
            throw new Error('No pattern loaded. Please select a pattern first.');
        }

        const userId = auth.currentUser.uid;
        const patternId = window.PATTERN_DATA.id;
        
        console.log('Creating sample progress entry...');
        console.log('Pattern data:', window.PATTERN_DATA);
        console.log('User ID:', userId);
        console.log('Pattern ID:', patternId);
        
        // Create a new project instance with correct function signature
        const projectResult = await createNewProject(
            window.db, 
            userId, 
            patternId, 
            `My ${window.PATTERN_DATA.metadata.name} Project`, // projectName
            'personal', // purpose
            null // recipient
        );
        
        const projectId = projectResult.projectId;
        console.log('Created project:', projectResult);
        
        // Update project with additional details using saveProjectProgress
        await saveProjectProgress(
            window.db,
            userId,
            patternId,
            projectId,
            {
                'projectDetails.yarns': [{
                    brand: 'Red Heart',
                    colorway: 'Soft Navy', 
                    weight: 'DK',
                    yardage: 300,
                    dyelot: 'A123'
                }],
                'projectDetails.tools.needleSize': 'US 6 (4.0mm)',
                'projectDetails.tools.otherTools': ['stitch markers', 'tapestry needle'],
                'notes.general': 'Starting my first project with this pattern!',
                currentStep: 5,
                completedSteps: [1, 2, 3, 4, 5],
                'experience.timeSpent.totalMinutes': 120,
                'projectDetails.modifications': ['Using different needle size for better gauge']
            }
        );
        
        // Add a project note using addProjectNote
        await addProjectNote(
            window.db,
            userId,
            patternId,
            projectId,
            'Completed the setup rows, moving on to the main pattern section.',
            5 // step number
        );
        
        console.log('‚úÖ Sample progress entry created!');
        console.log('Project ID:', projectId);
        
        // Refresh the progress display
        if (window.loadUserProgress) {
            await window.loadUserProgress();
        }
    }

    // Recreate the user_pattern_progress Firestore collection with enhanced schema
    async function recreateUserPatternProgressCollection() {
        if (!auth.currentUser) {
            throw new Error('User not authenticated');
        }

        console.log('üîÑ Recreating user_pattern_progress collection...');

        // This function will ensure the collection exists with proper structure
        // We'll create a sample document to establish the schema and then remove it
        
        const userId = auth.currentUser.uid;
        const samplePatternId = 'sample_pattern_id';
        const sampleProjectId = 'sample_project_id';
        const progressId = `${userId}_${samplePatternId}_${sampleProjectId}`;

        const sampleDocument = {
            userId,
            patternId: samplePatternId,
            projectId: sampleProjectId,
            currentStep: 1,
            totalSteps: 100,
            completedSteps: [],
            createdAt: serverTimestamp(),
            lastUpdated: serverTimestamp(),
            status: 'not_started',
            
            projectDetails: {
                projectName: 'Sample Project for Schema Setup',
                purpose: 'sample',
                recipient: null,
                deadline: null,
                yarns: [{
                    brand: 'Sample Brand',
                    colorway: 'Sample Color',
                    weight: 'DK',
                    yardage: 300,
                    dyelot: 'A123'
                }],
                tools: {
                    needleSize: 'US 6',
                    originalNeedleSize: 'US 6',
                    hookSize: null,
                    otherTools: ['stitch markers']
                },
                modifications: [],
                targetSize: {
                    width: null,
                    length: null
                },
                gauge: {
                    stitchesPerInch: null,
                    rowsPerInch: null,
                    measuredOn: null
                }
            },
            
            notes: {
                general: "Sample general notes",
                stepNotes: {},
                milestones: []
            },
            
            images: [],
            
            experience: {
                skillLevel: "intermediate",
                estimatedDifficulty: null,
                actualDifficulty: null,
                timeSpent: {
                    totalMinutes: 0,
                    sessionsCount: 0,
                    averageSessionLength: 0,
                    longestSession: 0
                },
                problemsEncountered: []
            },
            
            analytics: {
                stitchFinderUsage: 0,
                rowNavigationCount: 0,
                patternViewTime: 0,
                stepCompletionTimes: {},
                difficultyRating: null,
                enjoymentRating: null
            },
            
            privacy: {
                shareProgress: false,
                shareImages: false,
                shareNotes: false,
                shareAnalytics: false
            }
        };

        try {
            // Create the sample document to establish schema
            await setDoc(doc(window.db, 'user_pattern_progress', progressId), sampleDocument);
            console.log('‚úÖ Sample document created to establish schema');
            
            // Immediately delete the sample document
            await updateDoc(doc(window.db, 'user_pattern_progress', progressId), {
                deletedAt: serverTimestamp(),
                isDeleted: true
            });
            console.log('‚úÖ Sample document marked as deleted');
            
            console.log('üéâ user_pattern_progress collection recreated with enhanced schema!');
            
        } catch (error) {
            console.error('‚ùå Error recreating collection:', error);
            throw error;
        }
    }
    
    async function discoverPatterns() {
        try {
            const user = auth.currentUser;
            if (!user) {
                console.log('No user signed in - cannot load patterns');
                availablePatterns = [];
                populatePatternSelector();
                return;
            }
            
            console.log('üîç Loading patterns from Firestore...');
            availablePatterns = [];
            
            // Load patterns the user created
            const userPatternsQuery = query(
                collection(db, 'patterns'), 
                where('createdBy', '==', user.uid)
            );
            
            const userPatterns = await getDocs(userPatternsQuery);
            
            userPatterns.forEach(docSnapshot => {
                const data = docSnapshot.data();
                console.log('üìã Pattern data from Firestore:', data);
                
                // Handle both flat structure and nested metadata structure
                const metadata = data.metadata || data;
                availablePatterns.push({
                    id: docSnapshot.id,
                    filename: docSnapshot.id, // Use Firestore ID as filename for compatibility
                    name: metadata.name || data.name || 'Unknown Pattern',
                    author: metadata.author || data.author || 'Unknown Author',
                    craft: metadata.craft || data.craft || 'Unknown',
                    maxSteps: metadata.maxSteps || data.maxSteps || 'Unknown',
                    source: 'firestore'
                });
            });
            
            // TODO: Also load patterns shared with the user via pattern_access collection
            // For now, we're just loading user's own patterns
            
            console.log(`‚úÖ Found ${availablePatterns.length} patterns`);
            populatePatternSelector();
            
        } catch (error) {
            console.error('Error discovering patterns:', error);
            // Fallback to empty list
            availablePatterns = [];
            populatePatternSelector();
        }
    }
    
    // GLOBAL PATTERN SETUP FUNCTION - moved outside initializeViewer for global access
    window.setupViewer = function() {
        if (!PATTERN_DATA) {
            console.error('‚ùå setupViewer called without PATTERN_DATA');
            return;
        }
        
        console.log('üîß Setting up viewer with pattern:', PATTERN_DATA.metadata?.name);
        
        const footerControls = document.getElementById('footer-controls');
        footerControls.classList.remove('hidden');
        const { name, author, maxSteps: max } = PATTERN_DATA.metadata;
        
        // Update pattern display elements (now visible in project view)
        const patternNameEl = document.getElementById('pattern-name');
        const patternAuthorEl = document.getElementById('pattern-author');
        
        if (patternNameEl) patternNameEl.textContent = name;
        if (patternAuthorEl) patternAuthorEl.textContent = `by ${author}`;
        
        // Set global variables
        window.maxSteps = max;
        maxSteps = max;
        
        const stepInput = document.getElementById('current-step-input');
        if (stepInput) {
            stepInput.max = maxSteps;
            // Initialize with current project step if available
            if (window.currentProject && window.currentProject.currentStep) {
                currentStep = window.currentProject.currentStep;
                window.currentStep = currentStep;
                stepInput.value = currentStep;
                console.log('üîß Set initial step from project:', currentStep);
            } else {
                // Default to step 1
                currentStep = 1;
                window.currentStep = currentStep;
                stepInput.value = currentStep;
                console.log('üîß Set default step:', currentStep);
            }
        }
        
        progressKey = `pattern-progress-${name.replace(/\s+/g, '-')}`;
        
        // Update footer metadata with actual pattern name immediately
        const currentPatternName = document.getElementById('current-pattern-name');
        if (currentPatternName) {
            currentPatternName.textContent = name;
            console.log('üè∑Ô∏è Footer pattern name updated to:', name);
        }
        
        // Generate pattern content
        const patternContentEl = document.getElementById('pattern-content');
        patternContentEl.innerHTML = '';
        
        // Generate dynamic color theme based on pattern data
        // This replaces hardcoded CSS colors with pattern-specific colors
        generatePatternTheme(PATTERN_DATA);
        
        generateGlossary(PATTERN_DATA);
        generateInstructions(PATTERN_DATA);
        
        // Update footer metadata after content is generated
        updateFooterMetadata();
        
        // Load progress and setup interactions
        const currentStepInput = document.getElementById('current-step-input');
        if (currentStepInput && window.currentProject) {
            currentStepInput.value = window.currentProject.currentStep || 1;
        }
        setupInteractiveFeatures();
        
        console.log('‚úÖ Viewer setup complete for:', name);
        console.log('‚úÖ Current step:', currentStep, 'Max steps:', maxSteps);
    }

    // PROJECT MANAGEMENT FUNCTIONS
    async function loadUserProjects() {
        if (!auth.currentUser) return;
        
        try {
            const userId = auth.currentUser.uid;
            const progressQuery = query(
                collection(db, 'user_pattern_progress'),
                where('userId', '==', userId)
            );
            
            const querySnapshot = await getDocs(progressQuery);
            const projects = new Map();
            
            querySnapshot.forEach((doc) => {
                const data = doc.data();
                
                // Filter projects based on archive status and user preference
                if (data.status === 'archived' && !showArchivedProjects) {
                    console.log('üì¶ Skipping archived project:', data.projectId);
                    return;
                }
                if (data.status !== 'archived' && showArchivedProjects) {
                    console.log('üèÉ Skipping active project (showing archived only):', data.projectId);
                    return;
                }
                
                const projectKey = `${data.patternId}_${data.projectId}`;
                
                if (!projects.has(projectKey)) {
                    projects.set(projectKey, {
                        projectId: data.projectId,
                        patternId: data.patternId,
                        patternName: data.patternName || 'Unknown Pattern',
                        startDate: data.createdAt?.toDate?.() || new Date(),
                        lastUpdate: data.updatedAt?.toDate?.() || new Date(),
                        currentStep: data.currentStep || 1,
                        status: data.status || 'in_progress', // Include status for proper handling
                        projectDetails: data.projectDetails, // Include project details
                        notes: data.notes || [],
                        id: doc.id
                    });
                } else {
                    // Update with latest data
                    const existing = projects.get(projectKey);
                    if (data.updatedAt?.toDate?.() > existing.lastUpdate) {
                        existing.lastUpdate = data.updatedAt.toDate();
                        existing.currentStep = data.currentStep || existing.currentStep;
                    }
                }
            });
            
            return Array.from(projects.values());
        } catch (error) {
            console.error('Error loading user projects:', error);
            return [];
        }
    }
    
    async function loadFirestorePatterns() {
        try {
            const patternsQuery = query(collection(db, 'patterns'));
            const querySnapshot = await getDocs(patternsQuery);
            const patterns = [];
            
            querySnapshot.forEach((doc) => {
                const data = doc.data();
                patterns.push({
                    id: doc.id,
                    ...data,
                    filename: doc.id // Use document ID as filename
                });
            });
            
            return patterns;
        } catch (error) {
            console.error('Error loading Firestore patterns:', error);
            return [];
        }
    }
    
    async function populateProjectSelector() {
        const selector = document.getElementById('project-selector');
        const projectInfo = document.getElementById('project-info');
        const noProjectState = document.getElementById('no-project-state');
        
        selector.innerHTML = '<option value="">Loading your projects...</option>';
        
        const userProjects = await loadUserProjects();
        
        if (userProjects.length === 0) {
            const emptyMessage = showArchivedProjects ? 'No archived projects' : 'No active projects yet';
            selector.innerHTML = `<option value="">${emptyMessage}</option>`;
            projectInfo.classList.add('hidden');
            noProjectState.classList.remove('hidden');
            return;
        }
        
        noProjectState.classList.add('hidden');
        const selectMessage = showArchivedProjects ? '-- Select archived project --' : '-- Select a project --';
        selector.innerHTML = `<option value="">${selectMessage}</option>`;
        
        userProjects.forEach(project => {
            const option = document.createElement('option');
            option.value = `${project.patternId}_${project.projectId}`;
            
            // Create meaningful display name prioritizing user's project name
            let displayName;
            if (project.projectDetails?.projectName && 
                project.projectDetails.projectName !== `New Project ${new Date().toLocaleDateString()}` &&
                !project.projectDetails.projectName.includes('New Project')) {
                // User gave a custom project name - use it
                displayName = project.projectDetails.projectName;
            } else if (project.patternName) {
                // Use pattern name as fallback
                displayName = `${project.patternName} Project`;
            } else {
                // Last resort - use pattern ID
                displayName = `Pattern ${project.patternId}`;
            }
            
            // Add recipient info if available
            if (project.projectDetails?.recipient) {
                displayName += ` (for ${project.projectDetails.recipient})`;
            }
            
            // Add status indicator for archived projects
            if (showArchivedProjects && project.status === 'archived') {
                displayName += ' [ARCHIVED]';
            }
            
            option.textContent = displayName;
            selector.appendChild(option);
        });
        
        // Load last selected project from localStorage (only for active projects)
        if (!showArchivedProjects) {
            const lastProject = localStorage.getItem('lastSelectedProject');
            if (lastProject && userProjects.some(p => `${p.patternId}_${p.projectId}` === lastProject)) {
                selector.value = lastProject;
                await loadSelectedProject(lastProject, userProjects);
            }
        }
        
        selector.addEventListener('change', async (e) => {
            if (e.target.value) {
                await loadSelectedProject(e.target.value, userProjects);
                // Only save active projects as last selected (not archived ones)
                if (!showArchivedProjects) {
                    localStorage.setItem('lastSelectedProject', e.target.value);
                }
            } else {
                projectInfo.classList.add('hidden');
                resetViewer();
            }
        });
        
        // Enable delete button
        const deleteBtn = document.getElementById('delete-project-btn');
        deleteBtn.disabled = userProjects.length === 0;
        
    }
    
    async function loadSelectedProject(projectKey, userProjects) {
        const project = userProjects.find(p => `${p.patternId}_${p.projectId}` === projectKey);
        if (!project) return;
        
        // Update project info display
        const projectInfo = document.getElementById('project-info');
        const projectName = document.getElementById('project-name');
        const projectPatternInfo = document.getElementById('project-pattern-info');
        const projectPatternName = document.getElementById('project-pattern-name');
        const projectStartDate = document.getElementById('project-start-date');
        const projectLastUpdate = document.getElementById('project-last-update');
        const projectProgressSummary = document.getElementById('project-progress-summary');
        
        // Show the actual project name the user gave it
        const customProjectName = project.projectId.startsWith('Project_') 
            ? `${project.patternName} Project` // Auto-generated, show pattern name
            : project.projectId; // Custom name from user
        
        projectName.textContent = customProjectName;
        projectPatternInfo.textContent = `Working on step ${project.currentStep}`;
        projectPatternName.textContent = project.patternName; // This is the pattern name
        projectStartDate.textContent = project.startDate.toLocaleDateString();
        projectLastUpdate.textContent = project.lastUpdate.toLocaleDateString();
        projectProgressSummary.textContent = `Step ${project.currentStep}`;
        
        projectInfo.classList.remove('hidden');
        
        // Update archive/unarchive button based on project status and current view
        const deleteBtn = document.getElementById('delete-project-btn');
        if (showArchivedProjects && project.status === 'archived') {
            // Viewing archived project - show unarchive option
            deleteBtn.textContent = 'üì§ Restore';
            deleteBtn.title = 'Restore to Active Projects';
            deleteBtn.classList.remove('bg-orange-600', 'hover:bg-orange-700');
            deleteBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            deleteBtn.disabled = false;
        } else {
            // Viewing active project - show archive option
            deleteBtn.textContent = 'üóÉÔ∏è Archive';
            deleteBtn.title = 'Archive or Permanently Delete Project';
            deleteBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            deleteBtn.classList.add('bg-orange-600', 'hover:bg-orange-700');
            deleteBtn.disabled = false;
        }
        
        // Load the pattern data from Firestore - this will populate pattern-name and pattern-author elements
        await loadPatternFromFirestore(project.patternId);
        
        // Set current project and step - ensure all viewer components are updated
        window.currentProject = project;
        window.currentStep = project.currentStep;
        currentStep = project.currentStep; // Set local variable too
        
        console.log('üîß Project loaded, setting currentStep to:', currentStep);
        
        // Update step input if it exists
        const stepInput = document.getElementById('current-step-input');
        if (stepInput) {
            stepInput.value = currentStep;
            console.log('üîß Step input value set to:', stepInput.value);
        }
        
        if (window.currentStepRef) {
            window.currentStepRef.value = project.currentStep;
            // Force update the display to show pattern name and enable functionality
            if (window.PATTERN_DATA && window.updateStepDisplay) {
                window.updateStepDisplay(false);
            }
        }
        
        // Update footer to show pattern is loaded
        if (window.PATTERN_DATA) {
            const footerControls = document.getElementById('footer-controls');
            if (footerControls) {
                footerControls.classList.remove('hidden');
            }
        }
    }
    
    async function loadPatternFromFirestore(patternId) {
        try {
            const patternDoc = await getDoc(doc(db, 'patterns', patternId));
            if (patternDoc.exists()) {
                const patternData = patternDoc.data();
                window.PATTERN_DATA = patternData;
                PATTERN_DATA = patternData; // Also set local variable
                
                if (patternData.metadata && patternData.metadata.name) {
                    // Pattern loaded successfully, set up the viewer
                    window.setupViewer(); // Call the global function
                    console.log('‚úÖ Pattern loaded from Firestore:', patternData.metadata.name);
                } else {
                    console.error('‚ùå Pattern data missing required metadata');
                }
            } else {
                console.error('‚ùå Pattern not found in Firestore:', patternId);
            }
        } catch (error) {
            console.error('‚ùå Error loading pattern from Firestore:', error);
        }
    }
    
    function resetViewer() {
        const projectInfo = document.getElementById('project-info');
        const noProjectState = document.getElementById('no-project-state');
        
        projectInfo.classList.add('hidden');
        document.getElementById('pattern-content').innerHTML = '';
        footerControls.classList.add('hidden');
        PATTERN_DATA = null;
        window.currentProject = null;
        
        // Remove pattern-specific theme
        const existingStyle = document.getElementById('pattern-theme');
        if (existingStyle) {
            existingStyle.remove();
        }
    }
    
    // NEW PROJECT CREATION FUNCTIONS
    async function showNewProjectModal() {
        const firestorePatterns = await loadFirestorePatterns();
        
        if (firestorePatterns.length === 0) {
            alert('No patterns available. Please add patterns to Firestore first.');
            return;
        }
        
        let patternOptions = firestorePatterns.map(pattern => 
            `<option value="${pattern.id}">${pattern.metadata?.name || pattern.id} by ${pattern.metadata?.author || 'Unknown'}</option>`
        ).join('');
        
        const modalHtml = `
            <div id="new-project-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div class="bg-gray-800 p-6 rounded-lg max-w-md w-full mx-4">
                    <h3 class="text-xl font-bold text-white mb-4">Create New Project</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-300 mb-2">Select Pattern:</label>
                            <select id="new-project-pattern" class="w-full bg-gray-700 border border-gray-600 text-white rounded px-3 py-2">
                                <option value="">-- Choose a pattern --</option>
                                ${patternOptions}
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-300 mb-2">Project Name (optional):</label>
                            <input type="text" id="new-project-name" placeholder="e.g., 'Birthday Gift', 'Winter Scarf'" 
                                   class="w-full bg-gray-700 border border-gray-600 text-white rounded px-3 py-2">
                        </div>
                        <div class="flex space-x-3 pt-4">
                            <button id="create-project-btn" class="flex-1 bg-emerald-600 hover:bg-emerald-700 text-white py-2 rounded transition-colors">
                                Create Project
                            </button>
                            <button id="cancel-project-btn" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white py-2 rounded transition-colors">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
        // Event handlers
        document.getElementById('create-project-btn').addEventListener('click', createNewProjectUI);
        document.getElementById('cancel-project-btn').addEventListener('click', () => {
            document.getElementById('new-project-modal').remove();
        });
    }
    
    async function createNewProjectUI() {
        const patternId = document.getElementById('new-project-pattern').value;
        const projectName = document.getElementById('new-project-name').value.trim();
        
        if (!patternId) {
            alert('Please select a pattern.');
            return;
        }
        
        if (!auth.currentUser) {
            alert('Please log in first.');
            return;
        }
        
        try {
            const userId = auth.currentUser.uid;
            
            console.log('üîß Creating project with:', { patternId, projectName, userId });
            
            // Load pattern metadata to get the actual pattern name and author
            const patternDoc = await getDoc(doc(db, 'patterns', patternId));
            if (!patternDoc.exists()) {
                alert('Selected pattern not found.');
                return;
            }
            
            const patternData = patternDoc.data();
            const patternName = patternData.metadata?.name || patternData.name || 'Unknown Pattern';
            const patternAuthor = patternData.metadata?.author || patternData.author || 'Unknown Author';
            
            console.log('üìñ Loaded pattern data:', { patternName, patternAuthor });
            
            // Use user's custom project name or create a meaningful default
            const finalProjectName = projectName || `${patternName} Project`;
            
            console.log('üìù Final project name:', finalProjectName);
            
            // Create project with proper pattern information
            const newProject = await createNewProject(db, userId, patternId, finalProjectName);
            
            console.log('‚úÖ Project created:', newProject);
            
            // Update the project with pattern metadata that wasn't included in createNewProject
            const progressId = `${userId}_${patternId}_${newProject.projectId}`;
            await updateDoc(doc(db, 'user_pattern_progress', progressId), {
                patternName: patternName,
                patternAuthor: patternAuthor,
                'patternMetadata.name': patternName,
                'patternMetadata.author': patternAuthor,
                'patternMetadata.source': 'firestore'
            });
            
            console.log('‚úÖ Project metadata updated');
            
            // Close modal
            document.getElementById('new-project-modal').remove();
            
            // Refresh project list
            await populateProjectSelector();
            
            // Auto-select new project
            const selector = document.getElementById('project-selector');
            const newProjectKey = `${patternId}_${newProject.projectId}`;
            selector.value = newProjectKey;
            
            const userProjects = await loadUserProjects();
            await loadSelectedProject(newProjectKey, userProjects);
            
            console.log('‚úÖ New project created and selected:', newProject.projectId);
        } catch (error) {
            console.error('‚ùå Error creating project:', error);
            console.error('‚ùå Error details:', error.message, error.stack);
            alert(`Error creating project: ${error.message}`);
        }
    }
    
    // ARCHIVED PROJECTS FUNCTIONALITY
    async function toggleArchivedProjects() {
        showArchivedProjects = !showArchivedProjects;
        
        const btn = document.getElementById('show-archived-btn');
        const selector = document.getElementById('project-selector');
        
        if (showArchivedProjects) {
            // Switching to archived view
            btn.textContent = 'üèÉ Active';
            btn.title = 'View Active Projects';
            btn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
            btn.classList.add('bg-blue-600', 'hover:bg-blue-700');
            selector.innerHTML = '<option value="">Loading archived projects...</option>';
        } else {
            // Switching to active view
            btn.textContent = 'üì¶ Archived';
            btn.title = 'View Archived Projects';
            btn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
            btn.classList.add('bg-gray-600', 'hover:bg-gray-700');
            selector.innerHTML = '<option value="">Loading active projects...</option>';
        }
        
        // Clear current selection and reload projects
        const projectInfo = document.getElementById('project-info');
        projectInfo.classList.add('hidden');
        window.currentProject = null;
        
        // Reload project list with new filter
        await populateProjectSelector();
        
        console.log(`‚úÖ Toggled to ${showArchivedProjects ? 'archived' : 'active'} projects view`);
    }
    
    async function unarchiveProject(projectKey) {
        if (!projectKey) return;
        
        try {
            const userId = auth.currentUser.uid;
            const [patternId, projectId] = projectKey.split('_');
            const progressId = `${userId}_${patternId}_${projectId}`;
            
            console.log('üì§ Unarchiving project:', progressId);
            
            const docRef = doc(db, 'user_pattern_progress', progressId);
            await updateDoc(docRef, {
                status: 'in_progress',
                unarchivedAt: serverTimestamp(),
                lastUpdated: serverTimestamp()
            });
            
            console.log('‚úÖ Project unarchived successfully');
            alert('Project restored to active projects!');
            
            // Refresh the current view
            await populateProjectSelector();
            
        } catch (error) {
            console.error('‚ùå Error unarchiving project:', error);
            alert(`Error restoring project: ${error.message}`);
        }
    }
    
    async function checkAuthState() {
        console.log('=== STEP 1: Starting checkAuthState ===');
        
        // Set up auth state listener FIRST to catch any immediate auth changes
        console.log('=== STEP 1.5: Setting up auth state listener ===');
        onAuthStateChanged(auth, async (user) => {
            console.log('üî• AUTH STATE CHANGED EVENT FIRED!');
            console.log('Raw user object:', user);
            console.log('User from auth state change:', user ? user.email : 'null');
            console.log('User is null?', user === null);
            console.log('User is undefined?', user === undefined);
            
            if (user) {
                console.log('‚úÖ USER FOUND VIA AUTH STATE CHANGE!');
                console.log('User email:', user.email);
                console.log('User UID:', user.uid);
                console.log('User emailVerified:', user.emailVerified);
                console.log('User providerData:', user.providerData);
                
                try {
                    // Check if user exists in the users collection
                    console.log('üîç Checking user in Firebase users collection...');
                    console.log('Looking for document path: users/' + user.uid);
                    
                    const userDocRef = doc(db, "users", user.uid);
                    const userDocSnap = await getDoc(userDocRef);
                    
                    console.log('User document exists:', userDocSnap.exists());
                    
                    if (userDocSnap.exists()) {
                        // User exists, get their role and permissions
                        const userData = userDocSnap.data();
                        console.log('‚úÖ User found in database:', userData);
                        
                        // Get role details
                        const roleDocRef = doc(db, "roles", userData.role);
                        const roleDocSnap = await getDoc(roleDocRef);
                        
                        if (roleDocSnap.exists()) {
                            const roleData = roleDocSnap.data();
                            console.log('‚úÖ User role data:', roleData);
                            
                            // Check if user has permission to view patterns
                            if (roleData.permissions && roleData.permissions.includes('view_patterns')) {
                                console.log('üéâ User authorized - showing application');
                                
                                // Update last login
                                await updateDoc(userDocRef, {
                                    lastLogin: new Date().toISOString()
                                });
                                
                                showApplication(user, userData, roleData);
                            } else {
                                console.log('‚ùå User role does not have view_patterns permission');
                                showNotAuthorized(user);
                            }
                        } else {
                            console.log('‚ùå User role not found in roles collection');
                            showNotAuthorized(user);
                        }
                    } else {
                        // User doesn't exist, create them with default 'viewer' role
                        console.log('üë§ New user detected - creating user document');
                        console.log('User UID:', user.uid);
                        console.log('User email:', user.email);
                        console.log('User displayName:', user.displayName);
                        
                        try {
                            const newUserData = {
                                email: user.email,
                                displayName: user.displayName || user.email.split('@')[0],
                                role: 'viewer',
                                createdAt: new Date().toISOString(),
                                lastLogin: new Date().toISOString()
                            };
                            
                            console.log('Creating user document with data:', newUserData);
                            await setDoc(userDocRef, newUserData);
                            console.log('‚úÖ Successfully created new user document');
                            
                            // Get the viewer role permissions
                            const roleDocRef = doc(db, "roles", "viewer");
                            const roleDocSnap = await getDoc(roleDocRef);
                            const roleData = roleDocSnap.exists() ? roleDocSnap.data() : { permissions: ['view_patterns'], name: 'Viewer' };
                            
                            console.log('New user role data:', roleData);
                            showApplication(user, newUserData, roleData);
                            
                        } catch (createError) {
                            console.error('üö® Error creating user document:', createError);
                            console.log('Create error code:', createError.code);
                            console.log('Create error message:', createError.message);
                            
                            if (createError.code === 'permission-denied') {
                                alert('Permission denied when creating user account. Please check Firebase security rules.');
                            } else {
                                alert(`Error creating user account: ${createError.message}`);
                            }
                            
                            showNotAuthorized(user);
                        }
                    }
                    
                } catch (error) {
                    console.error('üö® Error checking user authorization:', error);
                    console.log('Error code:', error.code);
                    console.log('Error message:', error.message);
                    
                    if (error.code === 'permission-denied') {
                        alert('Permission denied. Please check your Firebase security rules.');
                    } else {
                        alert(`Authentication error: ${error.message}`);
                    }
                    
                    showNotAuthorized(user);
                }
                
            } else {
                console.log('Auth state change: no user - showing login screen');
                authContainer.classList.remove('hidden');
                appContainer.classList.add('hidden');
            }
        });
        
        console.log('=== STEP 2: Checking current auth state (popup method) ===');
        console.log('Current URL:', window.location.href);
        
        // With popup auth, we don't need to check for redirect results
        console.log('Using popup auth - skipping redirect result check');
        
        console.log('=== STEP 3: Checking current user ===');
        const currentUser = auth.currentUser;
        console.log('auth.currentUser:', currentUser);
        
        if (currentUser) {
            console.log('‚úÖ Current user found:', currentUser.email);
            // Trigger the auth state change manually if needed
            console.log('Current user exists, but auth state change should handle this');
        }
        
        console.log('=== STEP 4: No user found, showing login screen ===');
        authContainer.classList.remove('hidden');
        appContainer.classList.add('hidden');
    }

    // --- THEME TOGGLE FUNCTIONALITY ---
    function initThemeToggle() {
        const themeToggle = document.getElementById('theme-toggle');
        const themeIconDark = document.getElementById('theme-icon-dark');
        const themeIconLight = document.getElementById('theme-icon-light');
        const html = document.documentElement;
        
        // Get saved theme or default to dark
        const savedTheme = localStorage.getItem('theme') || 'dark';
        
        function updateTheme(theme) {
            if (theme === 'light') {
                html.setAttribute('data-theme', 'light');
                themeIconDark.classList.add('hidden');
                themeIconLight.classList.remove('hidden');
            } else {
                html.removeAttribute('data-theme');
                themeIconDark.classList.remove('hidden');
                themeIconLight.classList.add('hidden');
            }
            localStorage.setItem('theme', theme);
        }
        
        // Set initial theme
        updateTheme(savedTheme);
        
        // Toggle theme on click
        if (themeToggle) {
            themeToggle.addEventListener('click', () => {
                const currentTheme = html.getAttribute('data-theme') === 'light' ? 'light' : 'dark';
                const newTheme = currentTheme === 'light' ? 'dark' : 'light';
                updateTheme(newTheme);
            });
        }
    }

    // --- INITIALIZATION ---
    console.log('Script loaded, initializing app...');
    console.log('Current URL:', window.location.href);
    console.log('URL params:', window.location.search);
    
    // Initialize theme toggle 
    initThemeToggle();
    
    // Check for redirect result first (for mobile compatibility)
    checkRedirectResult();
    
    // Add global error handlers to catch any errors we might miss
    window.addEventListener('error', (event) => {
        console.log('üö® GLOBAL ERROR CAUGHT:', event.error);
        console.log('Error message:', event.message);
        console.log('Error filename:', event.filename);
        console.log('Error line:', event.lineno);
    });
    
    window.addEventListener('unhandledrejection', (event) => {
        console.log('üö® UNHANDLED PROMISE REJECTION:', event.reason);
        console.log('Promise:', event.promise);
    });
    
    // Check if we just came back from a redirect (Google referrer is key indicator)
    const hasGoogleReferrer = document.referrer.includes('accounts.google.com') || 
                             document.referrer.includes('google.com');
    const hasAuthParams = window.location.search.includes('code') || 
                         window.location.search.includes('state') || 
                         window.location.hash.includes('access_token');
    
    console.log('Google referrer detected:', hasGoogleReferrer);
    console.log('Auth URL params detected:', hasAuthParams);
    console.log('Document referrer:', document.referrer);
    
    // If we have any indication we came from Google auth, check immediately
    if (hasGoogleReferrer || hasAuthParams) {
        console.log('üîÑ DETECTED RETURN FROM GOOGLE - checking auth immediately (no delay)');
        checkAuthState();
    } else {
        console.log('üîç Normal page load - checking auth with small delay');
        setTimeout(() => {
            checkAuthState();
        }, 500);
    }

    // --- MAIN APP NAVIGATION ---
    appNav.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            const view = e.target.dataset.view;
            appNav.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            e.target.classList.add('active');
            
            // Analytics: Track section navigation
            if (auth.currentUser) {
                logStitchWitchQuery({
                    type: 'navigation',
                    action: 'section_switch',
                    section: view,
                    patternId: PATTERN_DATA?.id || 'unknown'
                }, db, auth);
            }
            
            if (view === 'viewer') {
                viewerSection.classList.remove('hidden');
                generatorSection.classList.add('hidden');
                footerControls.classList.remove('hidden');
            } else if (view === 'generator') {
                viewerSection.classList.add('hidden');
                generatorSection.classList.remove('hidden');
                footerControls.classList.add('hidden');
            }
        }
    });

    // --- VIEWER LOGIC (Your existing functions) ---
    async function initializeViewer() {
        const patternNameEl = document.getElementById('pattern-name');
        const patternAuthorEl = document.getElementById('pattern-author');
        const patternContentEl = document.getElementById('pattern-content');
        const stepInput = document.getElementById('current-step-input');
        const prevBtn = document.getElementById('prev-step');
        const nextBtn = document.getElementById('next-step');
        const stepTypeEl = document.getElementById('step-type');
        const toggleModeBtn = document.getElementById('toggle-mode');
        const findStitchBtn = document.getElementById('find-stitch-btn');
        const stitchInput = document.getElementById('stitch-input');
        const stitchPopup = document.getElementById('stitch-popup');
        const popupContent = document.getElementById('popup-content');
        const closePopupBtn = document.getElementById('close-popup-btn');

        async function loadPatternData(filename) {
            try {
                const response = await fetch(`/patterns/${filename}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                PATTERN_DATA = await response.json();
                window.PATTERN_DATA = PATTERN_DATA; // Make available globally
            } catch (error) {
                console.error("Could not load pattern data:", error);
                patternNameEl.textContent = "Error";
                patternContentEl.innerHTML = `<p class="text-center text-red-400">Failed to load pattern file. Check path and console.</p>`;
            }
        }

        // updateFooterMetadata is defined globally - see below
        

        function addTooltips(text) {
            if (!PATTERN_DATA.glossary) return text;
            const regex = new RegExp(`\\b(${Object.keys(PATTERN_DATA.glossary).join('|')})\\b(?![^<]*?>)`, 'g');
            return text.replace(regex, (match) => {
                const term = PATTERN_DATA.glossary[match];
                if (!term) return match;
                return `<span class="relative tooltip-trigger font-semibold cursor-pointer underline decoration-dotted decoration-1">${match}<span class="tooltip mono">${term.name}</span></span>`;
            });
        }
        
        // Functions imported from viewer-logic.js: saveProgress, loadProgress, loadProgressSimple
        
        function getStitchCount(stepNumber){
            if (!PATTERN_DATA || !PATTERN_DATA.steps) return 3;
            
            if(stitchCountsCache[stepNumber]) return stitchCountsCache[stepNumber];
            
            const instr = findInstructionForStep(stepNumber);
            
            // Try to get endingStitchCount from current schema
            if(instr && instr.endingStitchCount){
                stitchCountsCache[stepNumber] = instr.endingStitchCount;
                return instr.endingStitchCount;
            }
            
            // For step ranges, calculate based on the stepRange template
            if(instr && instr.stepRange && instr.startingStitchCount) {
                // This is a template step, calculate for the specific step number
                const stepOffset = stepNumber - instr.stepRange[0];
                const stitchCountChange = instr.stitchCountChange || 0;
                const count = instr.startingStitchCount + (stepOffset * stitchCountChange);
                stitchCountsCache[stepNumber] = count;
                return count;
            }
            
            // Calculate based on previous step
            if(stepNumber > 1){
                const prevCount = getStitchCount(stepNumber - 1);
                const stitchCountChange = instr?.stitchCountChange || 0;
                const count = prevCount + stitchCountChange;
                stitchCountsCache[stepNumber] = count;
                return count;
            }
            
            // Fallback to first step's starting count or default
            const firstStep = PATTERN_DATA.steps[0];
            return firstStep?.startingStitchCount || firstStep?.endingStitchCount || 3;
        }
        function expandPattern(patternArray){const expanded=[];patternArray.forEach(p=>{const match=p.match(/^([a-zA-Z_]+)(\d+)$/);if(match){const instruction=match[1];const count=parseInt(match[2],10);for(let i=0;i<count;i++)expanded.push(instruction);}else{expanded.push(p);}});return expanded;}
        function generateDynamicChunks(stepNumber){
            const instruction=findInstructionForStep(stepNumber);
            if(!instruction||!instruction.dynamicChunks)return null;
            
            // Use the chunks from the instruction as a template
            if(!instruction.chunks || !Array.isArray(instruction.chunks)) return null;
            
            const prevCount=getStitchCount(stepNumber-1);
            
            // Process each chunk, expanding dynamic placeholders
            return instruction.chunks.map(chunk => {
                const chunkCopy = {...chunk};
                
                // Handle dynamic count values
                if(typeof chunkCopy.count === 'string') {
                    if(chunkCopy.count === 'to marker') {
                        // Calculate stitches to marker based on pattern structure
                        chunkCopy.count = Math.max(1, Math.floor((prevCount - 7) / 2));
                    } else if(chunkCopy.count === 'to last 3') {
                        chunkCopy.count = Math.max(1, prevCount - 6);
                    } else if(chunkCopy.count === 'to last 4') {
                        chunkCopy.count = Math.max(1, Math.floor((prevCount - 7) / 2));
                    }
                    // Add more dynamic count patterns as needed
                }
                
                return {
                    name: `${chunkCopy.instruction.toUpperCase()}${chunkCopy.count > 1 ? chunkCopy.count : ''}`,
                    category: getInstructionCategory(chunkCopy.instruction, PATTERN_DATA),
                    pattern: [chunkCopy.count > 1 ? `${chunkCopy.instruction}${chunkCopy.count}` : chunkCopy.instruction]
                };
            });
        }
        
        function convertJSONChunksToInternalFormat(jsonChunks) {
            // Convert the JSON chunk format to the internal format expected by the stitch locator
            const converted = [];
            
            jsonChunks.forEach(chunk => {
                if (chunk.repeat) {
                    // Handle repeat structures
                    const pattern = chunk.repeat.instructions.map(inst => {
                        if (inst.count > 1) {
                            return `${inst.instruction}${inst.count}`;
                        }
                        return inst.instruction;
                    });
                    
                    converted.push({
                        name: `Repeat ${chunk.repeat.count} times`,
                        category: "main", // Default category
                        repeats: chunk.repeat.count,
                        pattern: pattern
                    });
                } else {
                    // Handle regular chunks
                    const pattern = chunk.count > 1 ? [`${chunk.instruction}${chunk.count}`] : [chunk.instruction];
                    converted.push({
                        name: chunk.instruction.toUpperCase(),
                        category: getInstructionCategory(chunk.instruction, PATTERN_DATA),
                        pattern: pattern
                    });
                }
            });
            
            return converted;
        }
        function getPatternForStitch(stepNumber,stitchNumber){
            const totalStitches=getStitchCount(stepNumber);
            if(stitchNumber<1||stitchNumber>totalStitches)return null;
            
            let instruction={...findInstructionForStep(stepNumber)};
            let chunks = null;
            
            if(instruction.dynamicChunks){
                chunks = generateDynamicChunks(stepNumber);
            } else if (instruction.chunks) {
                chunks = convertJSONChunksToInternalFormat(instruction.chunks);
            }
            
            if(!chunks){
                return{
                    sectionName:"This is a repeating instruction section.",
                    patternChunk:"Stitch-by-stitch data is not yet defined for this row type."
                };
            }
            
            let cumulativeStitches=0;
            for(const chunk of chunks){
                const expandedPattern=expandPattern(chunk.pattern);
                const repeats=chunk.repeats||1;
                const chunkStitchCount=expandedPattern.length*repeats;
                
                if(stitchNumber<=cumulativeStitches+chunkStitchCount){
                    const stitchInSection=stitchNumber-cumulativeStitches;
                    let sectionName=`<span class="${chunk.category||''}">${chunk.name}</span>`;
                    let fullPatternSequence=[];
                    
                    for(let i=0;i<repeats;i++){
                        fullPatternSequence.push(...expandedPattern);
                    }
                    
                    if(repeats>1){
                        const repeatNum=Math.ceil(stitchInSection/expandedPattern.length);
                        sectionName+=` (Repeat ${repeatNum} of ${repeats})`;
                    }
                    
                    const targetIndex=stitchInSection-1;
                    const windowSize=4;
                    const start=Math.max(0,targetIndex-windowSize);
                    const end=Math.min(fullPatternSequence.length,targetIndex+windowSize+1);
                    const patternWindow=fullPatternSequence.slice(start,end);
                    
                    let patternChunk=patternWindow.map((stitch,index)=>{
                        return(start+index===targetIndex)?`<span class="highlight">${stitch}</span>`:stitch;
                    }).join(' ');
                    
                    if(start>0)patternChunk='... '+patternChunk;
                    if(end<fullPatternSequence.length)patternChunk+=' ...';
                    
                    return{sectionName,patternChunk};
                }
                cumulativeStitches+=chunkStitchCount;
            }
            return null;
        }

        // Functions imported from viewer-logic.js: highlightCurrentStep, addRowNoteIndicator, loadRowNoteIndicators
        
        // Navigation handled by setupRowNavigation() function - keyboard listeners removed to prevent double triggers
        toggleModeBtn.addEventListener('click', () => {
            isStitchLocatorMode = !isStitchLocatorMode;
            stitchPopup.classList.add('hidden');
            document.getElementById('step-counter-ui').classList.toggle('opacity-0');
            document.getElementById('step-counter-ui').classList.toggle('pointer-events-none');
            document.getElementById('stitch-locator-ui').classList.toggle('opacity-0');
            document.getElementById('stitch-locator-ui').classList.toggle('pointer-events-none');
            
            if (isStitchLocatorMode) {
                toggleModeBtn.textContent = 'Switch to Row Counter';
                stitchInput.value = '';
                stitchInput.max = getStitchCount(currentStep);
                stitchInput.focus();
            } else {
                toggleModeBtn.textContent = 'Switch to Stitch Locator';
            }
        });
        
        closePopupBtn.addEventListener('click', () => stitchPopup.classList.add('hidden'));
        
        findStitchBtn.addEventListener('click', () => {
            const stitchNumber = parseInt(stitchInput.value);
            const patternInfo = getPatternForStitch(currentStep, stitchNumber);
            
            if (patternInfo) {
                popupContent.innerHTML = `
                    <h4 class="text-xl font-semibold text-white mb-2">Location (Row ${currentStep}, Stitch ${stitchNumber}):</h4>
                    <p class="mb-4">${patternInfo.sectionName}</p>
                    <h4 class="text-xl font-semibold text-white mb-2">Your Current Position:</h4>
                    <div class="result-chunk mono">${patternInfo.patternChunk}</div>
                `;
                stitchPopup.style.top = '50%';
                stitchPopup.style.left = '50%';
                stitchPopup.style.transform = 'translate(-50%, -50%)';
                stitchPopup.classList.remove('hidden');
            } else {
                popupContent.innerHTML = `
                    <div class="text-white text-center">
                        <p>Invalid stitch number for Row ${currentStep}. Please enter a number between 1 and ${getStitchCount(currentStep)}.</p>
                    </div>
                `;
                stitchPopup.style.top = '50%';
                stitchPopup.style.left = '50%';
                stitchPopup.style.transform = 'translate(-50%, -50%)';
                stitchPopup.classList.remove('hidden');
            }
        });

        // Pattern will be loaded when selected from dropdown
        // setupViewer will be called by loadSelectedPattern
    }
    
    async function loadSelectedPattern(patternId) {
        const patternNameEl = document.getElementById('pattern-name');
        const patternAuthorEl = document.getElementById('pattern-author');
        const patternContentEl = document.getElementById('pattern-content');
        
        try {
            patternNameEl.textContent = 'Loading...';
            
            // Find the selected pattern data from our loaded list
            const selectedPattern = availablePatterns.find(p => p.filename === patternId);
            
            if (selectedPattern && selectedPattern.source === 'firestore') {
                // Load from Firestore
                console.log('üìñ Loading pattern from Firestore:', patternId);
                const docRef = doc(db, 'patterns', patternId);
                const docSnap = await getDoc(docRef);
                
                if (!docSnap.exists()) {
                    throw new Error('Pattern not found in Firestore');
                }
                
                const firestoreData = docSnap.data();
                console.log('üîç Raw Firestore data:', firestoreData);
                
                // Extract pattern data from Firestore document
                // The pattern JSON was spread into the document, so we need to extract the pattern-specific fields
                PATTERN_DATA = {
                    metadata: firestoreData.metadata,
                    glossary: firestoreData.glossary,
                    steps: firestoreData.steps
                };
                
                console.log('üîç Extracted pattern data:', PATTERN_DATA);
                window.PATTERN_DATA = PATTERN_DATA; // Make available globally
                
            } else {
                // Fallback to JSON file loading (for compatibility)
                console.log('üìñ Loading pattern from JSON file:', patternId);
                const cacheBust = new Date().getTime();
                const response = await fetch(`/patterns/${patternId}?v=${cacheBust}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                PATTERN_DATA = await response.json();
                window.PATTERN_DATA = PATTERN_DATA; // Make available globally
            }
            
            // Generate dynamic CSS for this pattern's categories
            generatePatternTheme(PATTERN_DATA);
            
            // Update UI with pattern info
            const name = PATTERN_DATA.name || PATTERN_DATA.metadata?.name;
            const author = PATTERN_DATA.author || PATTERN_DATA.metadata?.author;
            const max = PATTERN_DATA.metadata?.maxSteps;
            
            patternNameEl.textContent = name;
            patternAuthorEl.textContent = `by ${author}`;
            maxSteps = max;
            document.getElementById('current-step-input').max = maxSteps;
            
            // Store current pattern ID for progress tracking
            currentPatternId = patternId;
            
            // Use project-specific progress key for proper project isolation
            if (window.currentProject && window.currentProject.projectId) {
                progressKey = `project-progress-${window.currentProject.projectId}`;
                console.log('üìÅ Using project-specific progress key:', progressKey);
            } else {
                // Fallback to pattern-only for compatibility
                progressKey = `pattern-progress-${patternId}`;
                console.log('üìÑ Using pattern-only progress key (no project selected):', progressKey);
            }
            
            // Clear and regenerate content
            patternContentEl.innerHTML = '';
            generateGlossary(PATTERN_DATA);
            generateInstructions(PATTERN_DATA);
            
            // Set up interactive features AFTER pattern content is generated
            setupInteractiveFeatures();
            
            // Load saved progress for this specific project
            if (window.currentProject && window.currentProject.currentStep) {
                currentStep = window.currentProject.currentStep;
                console.log('üìç Loaded currentStep from project:', currentStep);
            } else {
                // Fallback to localStorage for compatibility
                currentStep = await loadProgressSimple(progressKey);
                console.log('üìç Loaded currentStep from localStorage:', currentStep);
            }
            
            // Ensure currentStep is valid
            if (currentStep < 1) currentStep = 1;
            if (currentStep > maxSteps) currentStep = maxSteps;
            
            // Set up the current step display
            const stepInput = document.getElementById('current-step-input');
            if (stepInput) {
                stepInput.value = currentStep;
                stepInput.max = maxSteps;
            }
            
            // Update footer metadata immediately after pattern loads
            updateFooterMetadata();
            
            // Update display and scroll to current row (with timeout to ensure DOM is ready)
            setTimeout(() => {
                updateDisplay(currentStep, true);
                console.log('üéØ Pattern loaded and display updated for step:', currentStep);
            }, 100);
            
            footerControls.classList.remove('hidden');
            
        } catch (error) {
            console.error('Error loading pattern:', error);
            patternNameEl.textContent = 'Error Loading Pattern';
            patternAuthorEl.textContent = '';
            patternContentEl.innerHTML = `<p class="text-center text-red-400">Failed to load pattern: ${error.message}</p>`;
        }
    }

    // --- INTERACTIVE FEATURES SETUP ---
    function setupInteractiveFeatures() {
        console.log('üîß Setting up interactive features...');
        
        // Set up click handlers for color-coded stitches
        const stitchElements = document.querySelectorAll('.stitch-clickable');
        console.log('Found', stitchElements.length, 'clickable stitches');
        stitchElements.forEach(element => {
            element.addEventListener('click', (e) => {
                e.preventDefault();
                const stitchCode = element.dataset.stitch || element.textContent.trim();
                showStitchDefinition(stitchCode);
            });
        });
        
        // Set up stitch finder functionality
        setupStitchFinder();
        
        // Set up row navigation with auto-scroll
        setupRowNavigation();
        
        // Set up pattern tools sidebar
        setupPatternSidebar();
        
        // Populate sidebar glossary
        populateSidebarGlossary();
        
        console.log('‚úÖ Interactive features setup complete');
    }

    function scrollToCurrentRow() {
        if (typeof currentStep === 'undefined' || !currentStep) {
            console.log('Current step is undefined, cannot scroll to row');
            return;
        }
        
        const currentRowElement = document.querySelector(`[data-step="${currentStep}"]`);
        if (currentRowElement) {
            // Remove previous highlights
            document.querySelectorAll('.current-step').forEach(el => {
                el.classList.remove('current-step');
            });
            
            // Add current step highlight
            currentRowElement.classList.add('current-step');
            
            // Scroll to the row
            currentRowElement.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'center' 
            });
        } else {
            console.log(`No element found for step ${currentStep}`);
        }
    }

    // updateDisplay function is imported from viewer-logic.js - no local definition needed

    // highlightCurrentStep function is imported from viewer-logic.js

    // Add missing updateFooterMetadata function
    function updateCurrentStepDisplay() {
        const stepInput = document.getElementById('current-step-input');
        if (stepInput) {
            stepInput.value = currentStep;
        }
        
        // Highlight current step
        highlightCurrentStep(true);
        
        console.log('üîß Current step display updated to:', currentStep);
    }
    
    // updateFooterMetadata is defined globally as window.updateFooterMetadata below

    // saveProgress is imported from viewer-logic.js - no local definition needed

    function setupStitchFinder() {
        const findStitchBtn = document.getElementById('find-stitch-btn');
        const stitchInput = document.getElementById('stitch-input');
        
        function findStitch() {
            const stitchNumber = parseInt(stitchInput.value);
            if (!stitchNumber || stitchNumber < 1) {
                alert('Please enter a valid stitch number');
                return;
            }
            
            // Find the current row's instruction element
            const currentRowElement = document.querySelector(`[data-step="${currentStep}"]`);
            if (!currentRowElement) {
                alert('Current row not found');
                return;
            }
            
            // Highlight the stitch (basic implementation - could be enhanced)
            currentRowElement.style.backgroundColor = '#8b5cf6';
            currentRowElement.style.color = 'white';
            currentRowElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // Clear highlight after 3 seconds
            setTimeout(() => {
                currentRowElement.style.backgroundColor = '';
                currentRowElement.style.color = '';
            }, 3000);
            
            // Analytics
            if (auth.currentUser && window.db) {
                createStitchFinderQuery(currentStep, stitchNumber, auth.currentUser.uid, window.db);
            }
        }
        
        if (findStitchBtn) {
            findStitchBtn.addEventListener('click', findStitch);
        }
        
        if (stitchInput) {
            stitchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    findStitch();
                }
            });
        }
    }
    
    function setupRowNavigation() {
        console.log('üîß Setting up row navigation...');
        console.log('üîß Current values:', { currentStep, maxSteps, PATTERN_DATA: !!PATTERN_DATA });
        
        const stepInput = document.getElementById('current-step-input');
        const prevBtn = document.getElementById('prev-step');
        const nextBtn = document.getElementById('next-step');
        const toggleNotesBtn = document.getElementById('toggle-notes-sidebar');
        
        console.log('üîß Found elements:', {
            stepInput: !!stepInput,
            prevBtn: !!prevBtn,
            nextBtn: !!nextBtn,
            toggleNotesBtn: !!toggleNotesBtn
        });
        
        // Ensure we have global references
        window.currentStep = currentStep;
        window.maxSteps = maxSteps;
        
        // Remove existing listeners to prevent duplicates
        if (stepInput && !stepInput.hasAttribute('data-listener-added')) {
            stepInput.setAttribute('data-listener-added', 'true');
            
            // Add BOTH input and change listeners for better UX
            const handleStepChange = (value, shouldSave = true) => {
                const newStep = parseInt(value) || 1;
                if (newStep < 1 || newStep > maxSteps) return;
                
                currentStep = newStep;
                stepInput.value = currentStep;
                window.currentStep = currentStep; // Update global
                
                if (shouldSave) {
                    // Save immediately to localStorage for instant response
                    localStorage.setItem(progressKey, currentStep);
                    if (window.currentProject) {
                        window.currentProject.currentStep = currentStep;
                    }
                    
                    // Save to Firestore in background (non-blocking)
                    if (typeof saveProjectProgress === 'function' && window.currentProject && auth.currentUser) {
                        saveProjectProgress(db, auth.currentUser.uid, window.currentProject.patternId, window.currentProject.projectId, {
                            currentStep: currentStep
                        }).catch(err => console.warn('Background save failed:', err));
                    }
                }
                
                if (typeof updateDisplay === 'function') {
                    updateDisplay(currentStep, true);
                } else {
                    console.warn('‚ö†Ô∏è updateDisplay not available, using local update');
                    updateFooterMetadata();
                    highlightCurrentStep(true);
                }
            };
            
            // Real-time input for immediate visual feedback (no save spam)
            stepInput.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                if (value >= 1 && value <= maxSteps) {
                    handleStepChange(value, false); // Don't save on every keystroke
                }
            });
            
            // Final change event when user finishes typing (save to database)
            stepInput.addEventListener('change', (e) => {
                handleStepChange(e.target.value, true); // Save when user finishes
            });
            
            // Enter key for instant jump
            stepInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleStepChange(e.target.value, true);
                    e.target.blur(); // Remove focus after enter
                }
            });
            console.log('‚úÖ Step input listener added');
        }
        
        if (prevBtn && !prevBtn.hasAttribute('data-listener-added')) {
            prevBtn.setAttribute('data-listener-added', 'true');
            prevBtn.addEventListener('click', () => {
                if (currentStep > 1) {
                    currentStep--;
                    stepInput.value = currentStep;
                    window.currentStep = currentStep; // Update global
                    
                    // Save immediately to localStorage for instant response
                    localStorage.setItem(progressKey, currentStep);
                    window.currentProject.currentStep = currentStep;
                    
                    // Save to Firestore in background (non-blocking)
                    if (typeof saveProjectProgress === 'function' && window.currentProject && auth.currentUser) {
                        saveProjectProgress(db, auth.currentUser.uid, window.currentProject.patternId, window.currentProject.projectId, {
                            currentStep: currentStep
                        }).catch(err => console.warn('Background save failed:', err));
                    }
                    
                    if (typeof updateDisplay === 'function') {
                        updateDisplay(currentStep, true);
                    } else {
                        console.warn('‚ö†Ô∏è updateDisplay not available, using local update');
                        updateFooterMetadata();
                        highlightCurrentStep(true);
                    }
                }
            });
            console.log('‚úÖ Previous button listener added');
        }
        
        if (nextBtn && !nextBtn.hasAttribute('data-listener-added')) {
            nextBtn.setAttribute('data-listener-added', 'true');
            nextBtn.addEventListener('click', () => {
                if (currentStep < maxSteps) {
                    currentStep++;
                    stepInput.value = currentStep;
                    window.currentStep = currentStep; // Update global
                    
                    // Save immediately to localStorage for instant response
                    localStorage.setItem(progressKey, currentStep);
                    window.currentProject.currentStep = currentStep;
                    
                    // Save to Firestore in background (non-blocking)
                    if (typeof saveProjectProgress === 'function' && window.currentProject && auth.currentUser) {
                        saveProjectProgress(db, auth.currentUser.uid, window.currentProject.patternId, window.currentProject.projectId, {
                            currentStep: currentStep
                        }).catch(err => console.warn('Background save failed:', err));
                    }
                    
                    if (typeof updateDisplay === 'function') {
                        updateDisplay(currentStep, true);
                    } else {
                        console.warn('‚ö†Ô∏è updateDisplay not available, using local update');
                        updateFooterMetadata();
                        highlightCurrentStep(true);
                    }
                }
            });
            console.log('‚úÖ Next button listener added');
        }
        
        // Notes sidebar toggle
        if (toggleNotesBtn && !toggleNotesBtn.hasAttribute('data-listener-added')) {
            toggleNotesBtn.setAttribute('data-listener-added', 'true');
            toggleNotesBtn.addEventListener('click', () => {
                toggleNotesSidebar();
            });
            console.log('‚úÖ Notes toggle button listener added');
        }
        
        // Update footer when current step changes
        updateFooterMetadata();
    }
    
    // UPDATE FOOTER METADATA FUNCTION (defined globally as window.updateFooterMetadata below)
    
    // NOTES SIDEBAR FUNCTIONALITY
    function toggleNotesSidebar() {
        const sidebar = document.getElementById('notes-sidebar');
        const isOpen = !sidebar.classList.contains('translate-x-full');
        
        if (isOpen) {
            // Close sidebar
            sidebar.classList.add('translate-x-full');
        } else {
            // Open sidebar and load current project notes
            sidebar.classList.remove('translate-x-full');
            loadProjectNotes();
        }
    }
    
    async function loadProjectNotes() {
        if (!window.currentProject) return;
        
        // Load general notes
        const generalNotes = document.getElementById('general-notes');
        if (generalNotes && window.currentProject.notes?.general) {
            generalNotes.value = window.currentProject.notes.general;
        }
        
        // Load current row note
        const currentRowNote = document.getElementById('current-row-note');
        const currentRowLabel = document.getElementById('current-row-note-label');
        if (currentRowLabel) {
            currentRowLabel.textContent = window.currentStep || 1;
        }
        if (currentRowNote && window.currentProject.notes?.stepNotes?.[window.currentStep]) {
            currentRowNote.value = window.currentProject.notes.stepNotes[window.currentStep];
        } else if (currentRowNote) {
            currentRowNote.value = '';
        }
        
        // Load project details
        const yarnInfo = document.getElementById('yarn-info');
        const toolInfo = document.getElementById('tool-info');
        const modifications = document.getElementById('modifications');
        
        if (yarnInfo && window.currentProject.projectDetails?.yarns?.[0]) {
            const yarn = window.currentProject.projectDetails.yarns[0];
            yarnInfo.value = `${yarn.brand || ''} ${yarn.colorway || ''}`.trim();
        }
        
        if (toolInfo && window.currentProject.projectDetails?.tools?.needleSize) {
            toolInfo.value = window.currentProject.projectDetails.tools.needleSize;
        }
        
        if (modifications && window.currentProject.projectDetails?.modifications) {
            modifications.value = window.currentProject.projectDetails.modifications.join('\n');
        }
        
        // Update row notes list
        updateRowNotesList();
    }
    
    function updateRowNotesList() {
        const rowNotesList = document.getElementById('row-notes-list');
        if (!rowNotesList || !window.currentProject?.notes?.stepNotes) return;
        
        rowNotesList.innerHTML = '';
        
        Object.entries(window.currentProject.notes.stepNotes).forEach(([step, note]) => {
            const noteDiv = document.createElement('div');
            noteDiv.className = 'p-2 bg-gray-800 rounded text-sm';
            noteDiv.innerHTML = `
                <div class="flex justify-between items-start">
                    <span class="font-medium text-violet-300">Row ${step}:</span>
                    <button onclick="goToRowWithNote(${step})" class="text-xs text-blue-400 hover:text-blue-300">Go to</button>
                </div>
                <div class="text-gray-300 mt-1">${note}</div>
            `;
            rowNotesList.appendChild(noteDiv);
        });
    }
    
    // goToRowWithNote function is defined in js/app-main.js
    
    // Setup notes sidebar event listeners
    document.addEventListener('DOMContentLoaded', () => {
        const closeNotesBtn = document.getElementById('close-notes-sidebar');
        const saveRowNoteBtn = document.getElementById('save-row-note');
        const saveAllNotesBtn = document.getElementById('save-all-notes');
        
        if (closeNotesBtn) {
            closeNotesBtn.addEventListener('click', () => {
                const sidebar = document.getElementById('notes-sidebar');
                sidebar.classList.add('translate-x-full');
            });
        }
        
        if (saveRowNoteBtn) {
            saveRowNoteBtn.addEventListener('click', async () => {
                await saveCurrentRowNote();
            });
        }
        
        if (saveAllNotesBtn) {
            saveAllNotesBtn.addEventListener('click', async () => {
                await saveAllProjectNotes();
            });
        }
    });
    
    async function saveCurrentRowNote() {
        if (!window.currentProject || !auth.currentUser) return;
        
        const currentRowNote = document.getElementById('current-row-note');
        const noteText = currentRowNote?.value?.trim();
        
        if (!noteText) {
            alert('Please enter a note first.');
            return;
        }
        
        try {
            const stepNotesPath = `notes.stepNotes.${window.currentStep}`;
            await saveProjectProgress(db, auth.currentUser.uid, window.currentProject.patternId, window.currentProject.projectId, {
                [stepNotesPath]: noteText
            });
            
            // Update local project data
            if (!window.currentProject.notes) window.currentProject.notes = {};
            if (!window.currentProject.notes.stepNotes) window.currentProject.notes.stepNotes = {};
            window.currentProject.notes.stepNotes[window.currentStep] = noteText;
            
            updateRowNotesList();
            addRowNoteIndicator(window.currentStep);
            
            alert('Row note saved!');
        } catch (error) {
            console.error('Error saving row note:', error);
            alert('Error saving note. Please try again.');
        }
    }
    
    async function saveAllProjectNotes() {
        if (!window.currentProject || !auth.currentUser) return;
        
        const generalNotes = document.getElementById('general-notes')?.value?.trim();
        const yarnInfo = document.getElementById('yarn-info')?.value?.trim();
        const toolInfo = document.getElementById('tool-info')?.value?.trim();
        const modifications = document.getElementById('modifications')?.value?.trim();
        
        try {
            const updateData = {};
            
            if (generalNotes) {
                updateData['notes.general'] = generalNotes;
            }
            
            if (yarnInfo) {
                updateData['projectDetails.yarns'] = [{
                    brand: yarnInfo.split(' ')[0] || '',
                    colorway: yarnInfo.split(' ').slice(1).join(' ') || '',
                    weight: 'DK', // Default
                    yardage: null,
                    dyelot: null
                }];
            }
            
            if (toolInfo) {
                updateData['projectDetails.tools.needleSize'] = toolInfo;
            }
            
            if (modifications) {
                updateData['projectDetails.modifications'] = modifications.split('\n').filter(m => m.trim());
            }
            
            await saveProjectProgress(db, auth.currentUser.uid, window.currentProject.patternId, window.currentProject.projectId, updateData);
            
            alert('All notes saved!');
        } catch (error) {
            console.error('Error saving project notes:', error);
            alert('Error saving notes. Please try again.');
        }
    }
    
    // addRowNoteIndicator function is defined in js/app-main.js
    
    // loadRowNoteIndicators function is defined in js/app-main.js
    
    // highlightCurrentStep function is imported from viewer-logic.js
        
        // Setup Jump to Start button
        const jumpToStartBtn = document.getElementById('jump-to-start');
        if (jumpToStartBtn && !jumpToStartBtn.hasAttribute('data-listener-added')) {
            jumpToStartBtn.setAttribute('data-listener-added', 'true');
            jumpToStartBtn.addEventListener('click', () => {
                currentStep = 1;
                stepInput.value = 1;
                // Save immediately to localStorage for instant response
                localStorage.setItem(progressKey, currentStep);
                if (window.currentProject) window.currentProject.currentStep = currentStep;
                
                // Save to Firestore in background (non-blocking)
                if (typeof saveProjectProgress === 'function' && window.currentProject && auth.currentUser) {
                    saveProjectProgress(db, auth.currentUser.uid, window.currentProject.patternId, window.currentProject.projectId, {
                        currentStep: currentStep
                    }).catch(err => console.warn('Background save failed:', err));
                }
                updateDisplay(currentStep, true);
            });
        }
        
        // Setup Add Note button  
        const addNoteBtn = document.getElementById('add-note');
        if (addNoteBtn && !addNoteBtn.hasAttribute('data-listener-added')) {
            addNoteBtn.setAttribute('data-listener-added', 'true');
            addNoteBtn.addEventListener('click', () => {
                const note = prompt(`Add a note for row ${currentStep}:`);
                if (note && note.trim()) {
                    console.log('üìù Adding note for row', currentStep, ':', note.trim());
                    // Store note in localStorage for now
                    const notes = JSON.parse(localStorage.getItem('pattern-notes') || '{}');
                    const patternKey = PATTERN_DATA?.metadata?.title || 'unknown-pattern';
                    if (!notes[patternKey]) notes[patternKey] = {};
                    notes[patternKey][currentStep] = note.trim();
                    localStorage.setItem('pattern-notes', JSON.stringify(notes));
                    
                    // Show confirmation
                    const originalText = addNoteBtn.innerHTML;
                    addNoteBtn.innerHTML = '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg><span class="hidden lg:inline text-xs ml-1">Saved!</span>';
                    setTimeout(() => {
                        addNoteBtn.innerHTML = originalText;
                    }, 2000);
                }
            });
        }
        
        // Keyboard navigation - avoid calling button.click() to prevent double triggers
        if (!window.keyboardNavSetup) {
            window.keyboardNavSetup = true;
            document.addEventListener('keydown', (e) => {
                // Skip if user is typing in an input field
                if (document.activeElement === stepInput || document.activeElement.tagName === 'INPUT') {
                    return;
                }
                
                if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (currentStep < maxSteps) {
                        currentStep++;
                        stepInput.value = currentStep;
                        // Save immediately to localStorage for instant response
                        localStorage.setItem(progressKey, currentStep);
                        if (window.currentProject) window.currentProject.currentStep = currentStep;
                        
                        // Save to Firestore in background (non-blocking)
                        if (typeof saveProjectProgress === 'function' && window.currentProject && auth.currentUser) {
                            saveProjectProgress(db, auth.currentUser.uid, window.currentProject.patternId, window.currentProject.projectId, {
                                currentStep: currentStep
                            }).catch(err => console.warn('Background save failed:', err));
                        }
                        updateDisplay(currentStep, true);
                    }
                }
                
                if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (currentStep > 1) {
                        currentStep--;
                        stepInput.value = currentStep;
                        // Save immediately to localStorage for instant response
                        localStorage.setItem(progressKey, currentStep);
                        if (window.currentProject) window.currentProject.currentStep = currentStep;
                        
                        // Save to Firestore in background (non-blocking)
                        if (typeof saveProjectProgress === 'function' && window.currentProject && auth.currentUser) {
                            saveProjectProgress(db, auth.currentUser.uid, window.currentProject.patternId, window.currentProject.projectId, {
                                currentStep: currentStep
                            }).catch(err => console.warn('Background save failed:', err));
                        }
                        updateDisplay(currentStep, true);
                    }
                }
            });
        }
    

    // Footer update function is handled by viewer-logic.js

    // --- STITCH MODAL FUNCTIONALITY ---
    const stitchModal = document.getElementById('stitch-modal');
    const stitchModalTitle = document.getElementById('stitch-modal-title');
    const stitchModalDefinition = document.getElementById('stitch-modal-definition');
    const closeStitchModal = document.getElementById('close-stitch-modal');
    
    function showStitchDefinition(stitchCode) {
        if (!PATTERN_DATA || !PATTERN_DATA.glossary || !PATTERN_DATA.glossary[stitchCode]) {
            console.warn('No definition found for stitch:', stitchCode);
            return;
        }
        
        // Analytics: Track stitch definition views
        if (auth.currentUser) {
            logStitchWitchQuery({
                type: 'stitch_finder',
                action: 'view_definition',
                stitchCode: stitchCode,
                rowNumber: currentStep,
                patternId: PATTERN_DATA?.id || 'unknown'
            }, db, auth);
        }
        
        const glossaryEntry = PATTERN_DATA.glossary[stitchCode];
        stitchModalTitle.textContent = `${glossaryEntry.name} (${stitchCode})`;
        stitchModalDefinition.textContent = glossaryEntry.description;
        stitchModal.classList.remove('hidden');
    }
    
    function hideStitchDefinition() {
        stitchModal.classList.add('hidden');
    }
    
    // Event listeners for stitch interactions
    document.addEventListener('click', (e) => {
        if (e.target.classList.contains('stitch-clickable')) {
            e.preventDefault();
            const stitchCode = e.target.dataset.stitch || e.target.textContent.trim();
            showStitchDefinition(stitchCode);
        }
    });
    
    // --- PATTERN TOOLS SIDEBAR FUNCTIONALITY ---
    function setupPatternSidebar() {
        console.log('üîß Setting up pattern sidebar...');
        
        const sidebar = document.getElementById('pattern-sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const sidebarClose = document.getElementById('sidebar-close');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const returnToRowBtn = document.getElementById('return-to-row');
        
        console.log('Sidebar elements found:', {
            sidebar: !!sidebar,
            sidebarToggle: !!sidebarToggle,
            sidebarClose: !!sidebarClose,
            sidebarOverlay: !!sidebarOverlay,
            returnToRowBtn: !!returnToRowBtn
        });
        
        function toggleSidebar(e) {
            e.preventDefault();
            e.stopPropagation();
            
            console.log('üîÑ Toggling sidebar');
            if (sidebar && sidebarOverlay) {
                const isCurrentlyOpen = sidebar.classList.contains('open');
                console.log('Sidebar currently open:', isCurrentlyOpen);
                
                if (isCurrentlyOpen) {
                    // Close the sidebar
                    sidebar.classList.remove('open');
                    sidebarOverlay.classList.add('hidden');
                    console.log('‚úÖ Sidebar closed');
                } else {
                    // Open the sidebar
                    sidebar.classList.add('open');
                    sidebarOverlay.classList.remove('hidden');
                    console.log('‚úÖ Sidebar opened');
                }
            }
        }
        
        function closeSidebar() {
            console.log('‚ùå Closing sidebar');
            if (sidebar && sidebarOverlay) {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.add('hidden');
            }
        }
        
        if (sidebarToggle) {
            console.log('‚úÖ Adding click handler to sidebar toggle');
            sidebarToggle.addEventListener('click', toggleSidebar);
        } else {
            console.error('‚ùå Sidebar toggle button not found!');
        }
        
        if (sidebarClose) {
            sidebarClose.addEventListener('click', closeSidebar);
        }
        
        if (sidebarOverlay) {
            sidebarOverlay.addEventListener('click', closeSidebar);
        }
        
        if (returnToRowBtn) {
            returnToRowBtn.addEventListener('click', () => {
                scrollToCurrentRow();
                closeSidebar();
            });
        }
        
        // Handle section navigation
        const sidebarLinks = document.querySelector('.sidebar-links');
        if (sidebarLinks) {
            sidebarLinks.addEventListener('click', (e) => {
                if (e.target.dataset.section) {
                    e.preventDefault();
                    const sectionElement = document.getElementById(e.target.dataset.section);
                    if (sectionElement) {
                        sectionElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        closeSidebar();
                    }
                }
            });
        }
        
        console.log('‚úÖ Pattern sidebar setup complete');
    }
    
    function populateSidebarGlossary() {
        const sidebarGlossary = document.getElementById('sidebar-glossary');
        if (!sidebarGlossary || !PATTERN_DATA || !PATTERN_DATA.glossary) {
            return;
        }
        
        // Clear any existing event listeners
        const newSidebarGlossary = sidebarGlossary.cloneNode(false);
        sidebarGlossary.parentNode.replaceChild(newSidebarGlossary, sidebarGlossary);
        
        let glossaryHTML = '';
        const usedCategories = new Set();
        
        for (const [key, item] of Object.entries(PATTERN_DATA.glossary)) {
            if (item && item.name) {
                const category = getInstructionCategory(key, PATTERN_DATA);
                usedCategories.add(category);
                
                // Get the color for this category from CSS variables
                const colorClass = `color-${category}`;
                
                glossaryHTML += `
                    <div class="cursor-pointer hover:bg-gray-700 p-3 rounded mb-2 border-l-4 border-gray-600" data-stitch="${key}">
                        <div class="${colorClass} font-bold text-lg mb-1" style="color: var(--color-${category})">${key}</div>
                        <div class="text-gray-300 font-medium mb-1">${item.name}</div>
                        ${item.description ? `<div class="text-gray-400 text-sm leading-relaxed">${item.description}</div>` : ''}
                    </div>
                `;
            }
        }
        
        newSidebarGlossary.innerHTML = glossaryHTML;
        
        // Add click handlers for sidebar glossary items
        newSidebarGlossary.addEventListener('click', (e) => {
            const stitchDiv = e.target.closest('[data-stitch]');
            if (stitchDiv) {
                const stitchCode = stitchDiv.dataset.stitch;
                showStitchDefinition(stitchCode);
            }
        });
        
        // Update the sidebar color key to reflect the actual categories used
        updateSidebarColorKey(usedCategories);
    }
    
    closeStitchModal.addEventListener('click', hideStitchDefinition);
    stitchModal.addEventListener('click', (e) => {
        if (e.target === stitchModal) {
            hideStitchDefinition();
        }
    });
    
    // --- SECTION MANAGEMENT ---
    function showSection(sectionName) {
        console.log('üìç Switching to section:', sectionName);
        
        // Hide all main sections
        const viewerSection = document.getElementById('viewer-section');
        const generatorSection = document.getElementById('generator-section');
        const standaloneGenerator = document.getElementById('standalone-generator');
        const appContainer = document.getElementById('app-container');
        
        // Reset visibility
        if (viewerSection) viewerSection.classList.remove('hidden');
        if (generatorSection) generatorSection.classList.add('hidden');
        if (standaloneGenerator) standaloneGenerator.classList.add('hidden');
        
        switch(sectionName) {
            case 'viewer':
                // Default state - viewer section visible, others hidden
                if (appContainer) appContainer.classList.remove('hidden');
                break;
                
            case 'generator':
                // Show standalone generator, hide app container
                if (appContainer) appContainer.classList.add('hidden');
                if (standaloneGenerator) standaloneGenerator.classList.remove('hidden');
                break;
                
            default:
                console.warn('Unknown section:', sectionName);
                break;
        }
        
        // Log analytics
        if (auth.currentUser && window.db) {
            logStitchWitchQuery('navigation', 'section_switch', sectionName);
        }
    }
    
    // Close modal with Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !stitchModal.classList.contains('hidden')) {
            hideStitchDefinition();
        }
    });

    // --- PWA Service Worker ---
    // Temporarily disabled to fix caching issues during development
    // if('serviceWorker' in navigator){window.addEventListener('load',()=>{navigator.serviceWorker.register('/sw.js').then(reg=>console.log('SW registered.')).catch(err=>console.log('SW registration failed: ',err));});}

    // Script initialization complete
</script>
</body>
</html>